{"ast":null,"code":"// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n  return t;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\nimport { LogLevel } from \"./ILogger\";\nimport { HttpTransportType, TransferFormat } from \"./ITransport\";\nimport { LongPollingTransport } from \"./LongPollingTransport\";\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\nimport { WebSocketTransport } from \"./WebSocketTransport\";\nvar MAX_REDIRECTS = 100;\n/** @private */\nvar HttpConnection = /** @class */function () {\n  function HttpConnection(url, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.stopPromiseResolver = function () {};\n    this.features = {};\n    this.negotiateVersion = 1;\n    Arg.isRequired(url, \"url\");\n    this.logger = createLogger(options.logger);\n    this.baseUrl = this.resolveUrl(url);\n    options = options || {};\n    options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\n    if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\n      options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\n    } else {\n      throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\n    }\n    var webSocketModule = null;\n    var eventSourceModule = null;\n    if (Platform.isNode && typeof require !== \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      var requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\n      webSocketModule = requireFunc(\"ws\");\n      eventSourceModule = requireFunc(\"eventsource\");\n    }\n    if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\n      options.WebSocket = WebSocket;\n    } else if (Platform.isNode && !options.WebSocket) {\n      if (webSocketModule) {\n        options.WebSocket = webSocketModule;\n      }\n    }\n    if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\n      options.EventSource = EventSource;\n    } else if (Platform.isNode && !options.EventSource) {\n      if (typeof eventSourceModule !== \"undefined\") {\n        options.EventSource = eventSourceModule;\n      }\n    }\n    this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);\n    this.connectionState = \"Disconnected\" /* Disconnected */;\n    this.connectionStarted = false;\n    this.options = options;\n    this.onreceive = null;\n    this.onclose = null;\n  }\n  HttpConnection.prototype.start = function (transferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var message, message;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            transferFormat = transferFormat || TransferFormat.Binary;\n            Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\n            this.logger.log(LogLevel.Debug, \"Starting connection with transfer format '\" + TransferFormat[transferFormat] + \"'.\");\n            if (this.connectionState !== \"Disconnected\" /* Disconnected */) {\n              return [2 /*return*/, Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"))];\n            }\n            this.connectionState = \"Connecting\" /* Connecting */;\n            this.startInternalPromise = this.startInternal(transferFormat);\n            return [4 /*yield*/, this.startInternalPromise];\n          case 1:\n            _a.sent();\n            if (!(this.connectionState === \"Disconnecting\" /* Disconnecting */)) return [3 /*break*/, 3];\n            message = \"Failed to start the HttpConnection before stop() was called.\";\n            this.logger.log(LogLevel.Error, message);\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n            return [4 /*yield*/, this.stopPromise];\n          case 2:\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\n            _a.sent();\n            return [2 /*return*/, Promise.reject(new Error(message))];\n          case 3:\n            if (this.connectionState !== \"Connected\" /* Connected */) {\n              message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\n              this.logger.log(LogLevel.Error, message);\n              return [2 /*return*/, Promise.reject(new Error(message))];\n            }\n            _a.label = 4;\n          case 4:\n            this.connectionStarted = true;\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.send = function (data) {\n    if (this.connectionState !== \"Connected\" /* Connected */) {\n      return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\n    }\n    if (!this.sendQueue) {\n      this.sendQueue = new TransportSendQueue(this.transport);\n    }\n    // Transport will not be null if state is connected\n    return this.sendQueue.send(data);\n  };\n  HttpConnection.prototype.stop = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.connectionState === \"Disconnected\" /* Disconnected */) {\n              this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnected state.\");\n              return [2 /*return*/, Promise.resolve()];\n            }\n            if (this.connectionState === \"Disconnecting\" /* Disconnecting */) {\n              this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\n              return [2 /*return*/, this.stopPromise];\n            }\n            this.connectionState = \"Disconnecting\" /* Disconnecting */;\n            this.stopPromise = new Promise(function (resolve) {\n              // Don't complete stop() until stopConnection() completes.\n              _this.stopPromiseResolver = resolve;\n            });\n            // stopInternal should never throw so just observe it.\n            return [4 /*yield*/, this.stopInternal(error)];\n          case 1:\n            // stopInternal should never throw so just observe it.\n            _a.sent();\n            return [4 /*yield*/, this.stopPromise];\n          case 2:\n            _a.sent();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.stopInternal = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Set error as soon as possible otherwise there is a race between\n            // the transport closing and providing an error and the error from a close message\n            // We would prefer the close message error.\n            this.stopError = error;\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.startInternalPromise];\n          case 2:\n            _a.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            e_1 = _a.sent();\n            return [3 /*break*/, 4];\n          case 4:\n            if (!this.transport) return [3 /*break*/, 9];\n            _a.label = 5;\n          case 5:\n            _a.trys.push([5, 7,, 8]);\n            return [4 /*yield*/, this.transport.stop()];\n          case 6:\n            _a.sent();\n            return [3 /*break*/, 8];\n          case 7:\n            e_2 = _a.sent();\n            this.logger.log(LogLevel.Error, \"HttpConnection.transport.stop() threw error '\" + e_2 + \"'.\");\n            this.stopConnection();\n            return [3 /*break*/, 8];\n          case 8:\n            this.transport = undefined;\n            return [3 /*break*/, 10];\n          case 9:\n            this.logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\n            _a.label = 10;\n          case 10:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.startInternal = function (transferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var url, negotiateResponse, redirects, _loop_1, this_1, e_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            url = this.baseUrl;\n            this.accessTokenFactory = this.options.accessTokenFactory;\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 12,, 13]);\n            if (!this.options.skipNegotiation) return [3 /*break*/, 5];\n            if (!(this.options.transport === HttpTransportType.WebSockets)) return [3 /*break*/, 3];\n            // No need to add a connection ID in this case\n            this.transport = this.constructTransport(HttpTransportType.WebSockets);\n            // We should just call connect directly in this case.\n            // No fallback or negotiate in this case.\n            return [4 /*yield*/, this.startTransport(url, transferFormat)];\n          case 2:\n            // We should just call connect directly in this case.\n            // No fallback or negotiate in this case.\n            _a.sent();\n            return [3 /*break*/, 4];\n          case 3:\n            throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\n          case 4:\n            return [3 /*break*/, 11];\n          case 5:\n            negotiateResponse = null;\n            redirects = 0;\n            _loop_1 = function _loop_1() {\n              var accessToken_1;\n              return __generator(this, function (_a) {\n                switch (_a.label) {\n                  case 0:\n                    return [4 /*yield*/, this_1.getNegotiationResponse(url)];\n                  case 1:\n                    negotiateResponse = _a.sent();\n                    // the user tries to stop the connection when it is being started\n                    if (this_1.connectionState === \"Disconnecting\" /* Disconnecting */ || this_1.connectionState === \"Disconnected\" /* Disconnected */) {\n                      throw new Error(\"The connection was stopped during negotiation.\");\n                    }\n                    if (negotiateResponse.error) {\n                      throw new Error(negotiateResponse.error);\n                    }\n                    if (negotiateResponse.ProtocolVersion) {\n                      throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\n                    }\n                    if (negotiateResponse.url) {\n                      url = negotiateResponse.url;\n                    }\n                    if (negotiateResponse.accessToken) {\n                      accessToken_1 = negotiateResponse.accessToken;\n                      this_1.accessTokenFactory = function () {\n                        return accessToken_1;\n                      };\n                    }\n                    redirects++;\n                    return [2 /*return*/];\n                }\n              });\n            };\n\n            this_1 = this;\n            _a.label = 6;\n          case 6:\n            return [5 /*yield**/, _loop_1()];\n          case 7:\n            _a.sent();\n            _a.label = 8;\n          case 8:\n            if (negotiateResponse.url && redirects < MAX_REDIRECTS) return [3 /*break*/, 6];\n            _a.label = 9;\n          case 9:\n            if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\n              throw new Error(\"Negotiate redirection limit exceeded.\");\n            }\n            return [4 /*yield*/, this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];\n          case 10:\n            _a.sent();\n            _a.label = 11;\n          case 11:\n            if (this.transport instanceof LongPollingTransport) {\n              this.features.inherentKeepAlive = true;\n            }\n            if (this.connectionState === \"Connecting\" /* Connecting */) {\n              // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\n              // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\n              this.logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\n              this.connectionState = \"Connected\" /* Connected */;\n            }\n\n            return [3 /*break*/, 13];\n          case 12:\n            e_3 = _a.sent();\n            this.logger.log(LogLevel.Error, \"Failed to start the connection: \" + e_3);\n            this.connectionState = \"Disconnected\" /* Disconnected */;\n            this.transport = undefined;\n            // if start fails, any active calls to stop assume that start will complete the stop promise\n            this.stopPromiseResolver();\n            return [2 /*return*/, Promise.reject(e_3)];\n          case 13:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.getNegotiationResponse = function (url) {\n    return __awaiter(this, void 0, void 0, function () {\n      var headers, token, _a, name, value, negotiateUrl, response, negotiateResponse, e_4;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            headers = {};\n            if (!this.accessTokenFactory) return [3 /*break*/, 2];\n            return [4 /*yield*/, this.accessTokenFactory()];\n          case 1:\n            token = _b.sent();\n            if (token) {\n              headers[\"Authorization\"] = \"Bearer \" + token;\n            }\n            _b.label = 2;\n          case 2:\n            _a = getUserAgentHeader(), name = _a[0], value = _a[1];\n            headers[name] = value;\n            negotiateUrl = this.resolveNegotiateUrl(url);\n            this.logger.log(LogLevel.Debug, \"Sending negotiation request: \" + negotiateUrl + \".\");\n            _b.label = 3;\n          case 3:\n            _b.trys.push([3, 5,, 6]);\n            return [4 /*yield*/, this.httpClient.post(negotiateUrl, {\n              content: \"\",\n              headers: __assign({}, headers, this.options.headers),\n              withCredentials: this.options.withCredentials\n            })];\n          case 4:\n            response = _b.sent();\n            if (response.statusCode !== 200) {\n              return [2 /*return*/, Promise.reject(new Error(\"Unexpected status code returned from negotiate '\" + response.statusCode + \"'\"))];\n            }\n            negotiateResponse = JSON.parse(response.content);\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\n              // Negotiate version 0 doesn't use connectionToken\n              // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\n              negotiateResponse.connectionToken = negotiateResponse.connectionId;\n            }\n            return [2 /*return*/, negotiateResponse];\n          case 5:\n            e_4 = _b.sent();\n            this.logger.log(LogLevel.Error, \"Failed to complete negotiation with the server: \" + e_4);\n            return [2 /*return*/, Promise.reject(e_4)];\n          case 6:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  HttpConnection.prototype.createConnectUrl = function (url, connectionToken) {\n    if (!connectionToken) {\n      return url;\n    }\n    return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + (\"id=\" + connectionToken);\n  };\n  HttpConnection.prototype.createTransport = function (url, requestedTransport, negotiateResponse, requestedTransferFormat) {\n    return __awaiter(this, void 0, void 0, function () {\n      var connectUrl, transportExceptions, transports, negotiate, _i, transports_1, endpoint, transportOrError, ex_1, ex_2, message;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);\n            if (!this.isITransport(requestedTransport)) return [3 /*break*/, 2];\n            this.logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\n            this.transport = requestedTransport;\n            return [4 /*yield*/, this.startTransport(connectUrl, requestedTransferFormat)];\n          case 1:\n            _a.sent();\n            this.connectionId = negotiateResponse.connectionId;\n            return [2 /*return*/];\n          case 2:\n            transportExceptions = [];\n            transports = negotiateResponse.availableTransports || [];\n            negotiate = negotiateResponse;\n            _i = 0, transports_1 = transports;\n            _a.label = 3;\n          case 3:\n            if (!(_i < transports_1.length)) return [3 /*break*/, 13];\n            endpoint = transports_1[_i];\n            transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\n            if (!(transportOrError instanceof Error)) return [3 /*break*/, 4];\n            // Store the error and continue, we don't want to cause a re-negotiate in these cases\n            transportExceptions.push(endpoint.transport + \" failed: \" + transportOrError);\n            return [3 /*break*/, 12];\n          case 4:\n            if (!this.isITransport(transportOrError)) return [3 /*break*/, 12];\n            this.transport = transportOrError;\n            if (!!negotiate) return [3 /*break*/, 9];\n            _a.label = 5;\n          case 5:\n            _a.trys.push([5, 7,, 8]);\n            return [4 /*yield*/, this.getNegotiationResponse(url)];\n          case 6:\n            negotiate = _a.sent();\n            return [3 /*break*/, 8];\n          case 7:\n            ex_1 = _a.sent();\n            return [2 /*return*/, Promise.reject(ex_1)];\n          case 8:\n            connectUrl = this.createConnectUrl(url, negotiate.connectionToken);\n            _a.label = 9;\n          case 9:\n            _a.trys.push([9, 11,, 12]);\n            return [4 /*yield*/, this.startTransport(connectUrl, requestedTransferFormat)];\n          case 10:\n            _a.sent();\n            this.connectionId = negotiate.connectionId;\n            return [2 /*return*/];\n          case 11:\n            ex_2 = _a.sent();\n            this.logger.log(LogLevel.Error, \"Failed to start the transport '\" + endpoint.transport + \"': \" + ex_2);\n            negotiate = undefined;\n            transportExceptions.push(endpoint.transport + \" failed: \" + ex_2);\n            if (this.connectionState !== \"Connecting\" /* Connecting */) {\n              message = \"Failed to select transport before stop() was called.\";\n              this.logger.log(LogLevel.Debug, message);\n              return [2 /*return*/, Promise.reject(new Error(message))];\n            }\n            return [3 /*break*/, 12];\n          case 12:\n            _i++;\n            return [3 /*break*/, 3];\n          case 13:\n            if (transportExceptions.length > 0) {\n              return [2 /*return*/, Promise.reject(new Error(\"Unable to connect to the server with any of the available transports. \" + transportExceptions.join(\" \")))];\n            }\n            return [2 /*return*/, Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"))];\n        }\n      });\n    });\n  };\n  HttpConnection.prototype.constructTransport = function (transport) {\n    switch (transport) {\n      case HttpTransportType.WebSockets:\n        if (!this.options.WebSocket) {\n          throw new Error(\"'WebSocket' is not supported in your environment.\");\n        }\n        return new WebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket, this.options.headers || {});\n      case HttpTransportType.ServerSentEvents:\n        if (!this.options.EventSource) {\n          throw new Error(\"'EventSource' is not supported in your environment.\");\n        }\n        return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource, this.options.withCredentials, this.options.headers || {});\n      case HttpTransportType.LongPolling:\n        return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.withCredentials, this.options.headers || {});\n      default:\n        throw new Error(\"Unknown transport: \" + transport + \".\");\n    }\n  };\n  HttpConnection.prototype.startTransport = function (url, transferFormat) {\n    var _this = this;\n    this.transport.onreceive = this.onreceive;\n    this.transport.onclose = function (e) {\n      return _this.stopConnection(e);\n    };\n    return this.transport.connect(url, transferFormat);\n  };\n  HttpConnection.prototype.resolveTransportOrError = function (endpoint, requestedTransport, requestedTransferFormat) {\n    var transport = HttpTransportType[endpoint.transport];\n    if (transport === null || transport === undefined) {\n      this.logger.log(LogLevel.Debug, \"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\n      return new Error(\"Skipping transport '\" + endpoint.transport + \"' because it is not supported by this client.\");\n    } else {\n      if (transportMatches(requestedTransport, transport)) {\n        var transferFormats = endpoint.transferFormats.map(function (s) {\n          return TransferFormat[s];\n        });\n        if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\n          if (transport === HttpTransportType.WebSockets && !this.options.WebSocket || transport === HttpTransportType.ServerSentEvents && !this.options.EventSource) {\n            this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it is not supported in your environment.'\");\n            return new Error(\"'\" + HttpTransportType[transport] + \"' is not supported in your environment.\");\n          } else {\n            this.logger.log(LogLevel.Debug, \"Selecting transport '\" + HttpTransportType[transport] + \"'.\");\n            try {\n              return this.constructTransport(transport);\n            } catch (ex) {\n              return ex;\n            }\n          }\n        } else {\n          this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it does not support the requested transfer format '\" + TransferFormat[requestedTransferFormat] + \"'.\");\n          return new Error(\"'\" + HttpTransportType[transport] + \"' does not support \" + TransferFormat[requestedTransferFormat] + \".\");\n        }\n      } else {\n        this.logger.log(LogLevel.Debug, \"Skipping transport '\" + HttpTransportType[transport] + \"' because it was disabled by the client.\");\n        return new Error(\"'\" + HttpTransportType[transport] + \"' is disabled by the client.\");\n      }\n    }\n  };\n  HttpConnection.prototype.isITransport = function (transport) {\n    return transport && typeof transport === \"object\" && \"connect\" in transport;\n  };\n  HttpConnection.prototype.stopConnection = function (error) {\n    var _this = this;\n    this.logger.log(LogLevel.Debug, \"HttpConnection.stopConnection(\" + error + \") called while in state \" + this.connectionState + \".\");\n    this.transport = undefined;\n    // If we have a stopError, it takes precedence over the error from the transport\n    error = this.stopError || error;\n    this.stopError = undefined;\n    if (this.connectionState === \"Disconnected\" /* Disconnected */) {\n      this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stopConnection(\" + error + \") was ignored because the connection is already in the disconnected state.\");\n      return;\n    }\n    if (this.connectionState === \"Connecting\" /* Connecting */) {\n      this.logger.log(LogLevel.Warning, \"Call to HttpConnection.stopConnection(\" + error + \") was ignored because the connection is still in the connecting state.\");\n      throw new Error(\"HttpConnection.stopConnection(\" + error + \") was called while the connection is still in the connecting state.\");\n    }\n    if (this.connectionState === \"Disconnecting\" /* Disconnecting */) {\n      // A call to stop() induced this call to stopConnection and needs to be completed.\n      // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\n      this.stopPromiseResolver();\n    }\n    if (error) {\n      this.logger.log(LogLevel.Error, \"Connection disconnected with error '\" + error + \"'.\");\n    } else {\n      this.logger.log(LogLevel.Information, \"Connection disconnected.\");\n    }\n    if (this.sendQueue) {\n      this.sendQueue.stop().catch(function (e) {\n        _this.logger.log(LogLevel.Error, \"TransportSendQueue.stop() threw error '\" + e + \"'.\");\n      });\n      this.sendQueue = undefined;\n    }\n    this.connectionId = undefined;\n    this.connectionState = \"Disconnected\" /* Disconnected */;\n    if (this.connectionStarted) {\n      this.connectionStarted = false;\n      try {\n        if (this.onclose) {\n          this.onclose(error);\n        }\n      } catch (e) {\n        this.logger.log(LogLevel.Error, \"HttpConnection.onclose(\" + error + \") threw error '\" + e + \"'.\");\n      }\n    }\n  };\n  HttpConnection.prototype.resolveUrl = function (url) {\n    // startsWith is not supported in IE\n    if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\n      return url;\n    }\n    if (!Platform.isBrowser || !window.document) {\n      throw new Error(\"Cannot resolve '\" + url + \"'.\");\n    }\n    // Setting the url to the href propery of an anchor tag handles normalization\n    // for us. There are 3 main cases.\n    // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\n    // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\n    // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\n    var aTag = window.document.createElement(\"a\");\n    aTag.href = url;\n    this.logger.log(LogLevel.Information, \"Normalizing '\" + url + \"' to '\" + aTag.href + \"'.\");\n    return aTag.href;\n  };\n  HttpConnection.prototype.resolveNegotiateUrl = function (url) {\n    var index = url.indexOf(\"?\");\n    var negotiateUrl = url.substring(0, index === -1 ? url.length : index);\n    if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\n      negotiateUrl += \"/\";\n    }\n    negotiateUrl += \"negotiate\";\n    negotiateUrl += index === -1 ? \"\" : url.substring(index);\n    if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\n      negotiateUrl += index === -1 ? \"?\" : \"&\";\n      negotiateUrl += \"negotiateVersion=\" + this.negotiateVersion;\n    }\n    return negotiateUrl;\n  };\n  return HttpConnection;\n}();\nexport { HttpConnection };\nfunction transportMatches(requestedTransport, actualTransport) {\n  return !requestedTransport || (actualTransport & requestedTransport) !== 0;\n}\n/** @private */\nvar TransportSendQueue = /** @class */function () {\n  function TransportSendQueue(transport) {\n    this.transport = transport;\n    this.buffer = [];\n    this.executing = true;\n    this.sendBufferedData = new PromiseSource();\n    this.transportResult = new PromiseSource();\n    this.sendLoopPromise = this.sendLoop();\n  }\n  TransportSendQueue.prototype.send = function (data) {\n    this.bufferData(data);\n    if (!this.transportResult) {\n      this.transportResult = new PromiseSource();\n    }\n    return this.transportResult.promise;\n  };\n  TransportSendQueue.prototype.stop = function () {\n    this.executing = false;\n    this.sendBufferedData.resolve();\n    return this.sendLoopPromise;\n  };\n  TransportSendQueue.prototype.bufferData = function (data) {\n    if (this.buffer.length && typeof this.buffer[0] !== typeof data) {\n      throw new Error(\"Expected data to be of type \" + typeof this.buffer + \" but was of type \" + typeof data);\n    }\n    this.buffer.push(data);\n    this.sendBufferedData.resolve();\n  };\n  TransportSendQueue.prototype.sendLoop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var transportResult, data, error_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!true) return [3 /*break*/, 6];\n            return [4 /*yield*/, this.sendBufferedData.promise];\n          case 1:\n            _a.sent();\n            if (!this.executing) {\n              if (this.transportResult) {\n                this.transportResult.reject(\"Connection stopped.\");\n              }\n              return [3 /*break*/, 6];\n            }\n            this.sendBufferedData = new PromiseSource();\n            transportResult = this.transportResult;\n            this.transportResult = undefined;\n            data = typeof this.buffer[0] === \"string\" ? this.buffer.join(\"\") : TransportSendQueue.concatBuffers(this.buffer);\n            this.buffer.length = 0;\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            return [4 /*yield*/, this.transport.send(data)];\n          case 3:\n            _a.sent();\n            transportResult.resolve();\n            return [3 /*break*/, 5];\n          case 4:\n            error_1 = _a.sent();\n            transportResult.reject(error_1);\n            return [3 /*break*/, 5];\n          case 5:\n            return [3 /*break*/, 0];\n          case 6:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  TransportSendQueue.concatBuffers = function (arrayBuffers) {\n    var totalLength = arrayBuffers.map(function (b) {\n      return b.byteLength;\n    }).reduce(function (a, b) {\n      return a + b;\n    });\n    var result = new Uint8Array(totalLength);\n    var offset = 0;\n    for (var _i = 0, arrayBuffers_1 = arrayBuffers; _i < arrayBuffers_1.length; _i++) {\n      var item = arrayBuffers_1[_i];\n      result.set(new Uint8Array(item), offset);\n      offset += item.byteLength;\n    }\n    return result.buffer;\n  };\n  return TransportSendQueue;\n}();\nexport { TransportSendQueue };\nvar PromiseSource = /** @class */function () {\n  function PromiseSource() {\n    var _this = this;\n    this.promise = new Promise(function (resolve, reject) {\n      var _a;\n      return _a = [resolve, reject], _this.resolver = _a[0], _this.rejecter = _a[1], _a;\n    });\n  }\n  PromiseSource.prototype.resolve = function () {\n    this.resolver();\n  };\n  PromiseSource.prototype.reject = function (reason) {\n    this.rejecter(reason);\n  };\n  return PromiseSource;\n}();","map":{"version":3,"names":["DefaultHttpClient","LogLevel","HttpTransportType","TransferFormat","LongPollingTransport","ServerSentEventsTransport","Arg","createLogger","getUserAgentHeader","Platform","WebSocketTransport","MAX_REDIRECTS","HttpConnection","url","options","stopPromiseResolver","features","negotiateVersion","isRequired","logger","baseUrl","resolveUrl","logMessageContent","undefined","withCredentials","Error","webSocketModule","eventSourceModule","isNode","require","requireFunc","__webpack_require__","__non_webpack_require__","WebSocket","EventSource","httpClient","connectionState","connectionStarted","onreceive","onclose","prototype","start","transferFormat","Binary","isIn","log","Debug","Promise","reject","startInternalPromise","startInternal","_a","sent","message","stopPromise","send","data","sendQueue","TransportSendQueue","transport","stop","error","resolve","_this","stopInternal","stopError","e_2","stopConnection","accessTokenFactory","skipNegotiation","WebSockets","constructTransport","startTransport","negotiateResponse","redirects","this_1","getNegotiationResponse","ProtocolVersion","accessToken","accessToken_1","createTransport","inherentKeepAlive","e_3","headers","token","_b","name","value","negotiateUrl","resolveNegotiateUrl","post","content","__assign","response","statusCode","JSON","parse","connectionToken","connectionId","e_4","createConnectUrl","indexOf","requestedTransport","requestedTransferFormat","connectUrl","isITransport","transportExceptions","transports","availableTransports","negotiate","transports_1","_i","length","endpoint","transportOrError","resolveTransportOrError","push","ex_1","ex_2","join","ServerSentEvents","LongPolling","e","connect","transportMatches","transferFormats","map","s","ex","Warning","Information","catch","lastIndexOf","isBrowser","window","document","aTag","createElement","href","index","substring","actualTransport","buffer","executing","sendBufferedData","PromiseSource","transportResult","sendLoopPromise","sendLoop","bufferData","promise","concatBuffers","error_1","arrayBuffers","totalLength","b","byteLength","reduce","a","result","Uint8Array","offset","arrayBuffers_1","item","set","resolver","rejecter","reason"],"sources":["../../src/HttpConnection.ts"],"sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { DefaultHttpClient } from \"./DefaultHttpClient\";\r\nimport { HttpClient } from \"./HttpClient\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { IHttpConnectionOptions } from \"./IHttpConnectionOptions\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { HttpTransportType, ITransport, TransferFormat } from \"./ITransport\";\r\nimport { LongPollingTransport } from \"./LongPollingTransport\";\r\nimport { ServerSentEventsTransport } from \"./ServerSentEventsTransport\";\r\nimport { Arg, createLogger, getUserAgentHeader, Platform } from \"./Utils\";\r\nimport { WebSocketTransport } from \"./WebSocketTransport\";\r\n\r\n/** @private */\r\nconst enum ConnectionState {\r\n    Connecting = \"Connecting\",\r\n    Connected = \"Connected\",\r\n    Disconnected = \"Disconnected\",\r\n    Disconnecting = \"Disconnecting\",\r\n}\r\n\r\n/** @private */\r\nexport interface INegotiateResponse {\r\n    connectionId?: string;\r\n    connectionToken?: string;\r\n    negotiateVersion?: number;\r\n    availableTransports?: IAvailableTransport[];\r\n    url?: string;\r\n    accessToken?: string;\r\n    error?: string;\r\n}\r\n\r\n/** @private */\r\nexport interface IAvailableTransport {\r\n    transport: keyof typeof HttpTransportType;\r\n    transferFormats: Array<keyof typeof TransferFormat>;\r\n}\r\n\r\nconst MAX_REDIRECTS = 100;\r\n\r\n/** @private */\r\nexport class HttpConnection implements IConnection {\r\n    private connectionState: ConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private connectionStarted: boolean;\r\n    private readonly httpClient: HttpClient;\r\n    private readonly logger: ILogger;\r\n    private readonly options: IHttpConnectionOptions;\r\n    private transport?: ITransport;\r\n    private startInternalPromise?: Promise<void>;\r\n    private stopPromise?: Promise<void>;\r\n    private stopPromiseResolver: (value?: PromiseLike<void>) => void = () => {};\r\n    private stopError?: Error;\r\n    private accessTokenFactory?: () => string | Promise<string>;\r\n    private sendQueue?: TransportSendQueue;\r\n\r\n    public readonly features: any = {};\r\n    public baseUrl: string;\r\n    public connectionId?: string;\r\n    public onreceive: ((data: string | ArrayBuffer) => void) | null;\r\n    public onclose: ((e?: Error) => void) | null;\r\n\r\n    private readonly negotiateVersion: number = 1;\r\n\r\n    constructor(url: string, options: IHttpConnectionOptions = {}) {\r\n        Arg.isRequired(url, \"url\");\r\n\r\n        this.logger = createLogger(options.logger);\r\n        this.baseUrl = this.resolveUrl(url);\r\n\r\n        options = options || {};\r\n        options.logMessageContent = options.logMessageContent === undefined ? false : options.logMessageContent;\r\n        if (typeof options.withCredentials === \"boolean\" || options.withCredentials === undefined) {\r\n            options.withCredentials = options.withCredentials === undefined ? true : options.withCredentials;\r\n        } else {\r\n            throw new Error(\"withCredentials option was not a 'boolean' or 'undefined' value\");\r\n        }\r\n\r\n        let webSocketModule: any = null;\r\n        let eventSourceModule: any = null;\r\n\r\n        if (Platform.isNode && typeof require !== \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n            webSocketModule = requireFunc(\"ws\");\r\n            eventSourceModule = requireFunc(\"eventsource\");\r\n        }\r\n\r\n        if (!Platform.isNode && typeof WebSocket !== \"undefined\" && !options.WebSocket) {\r\n            options.WebSocket = WebSocket;\r\n        } else if (Platform.isNode && !options.WebSocket) {\r\n            if (webSocketModule) {\r\n                options.WebSocket = webSocketModule;\r\n            }\r\n        }\r\n\r\n        if (!Platform.isNode && typeof EventSource !== \"undefined\" && !options.EventSource) {\r\n            options.EventSource = EventSource;\r\n        } else if (Platform.isNode && !options.EventSource) {\r\n            if (typeof eventSourceModule !== \"undefined\") {\r\n                options.EventSource = eventSourceModule;\r\n            }\r\n        }\r\n\r\n        this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);\r\n        this.connectionState = ConnectionState.Disconnected;\r\n        this.connectionStarted = false;\r\n        this.options = options;\r\n\r\n        this.onreceive = null;\r\n        this.onclose = null;\r\n    }\r\n\r\n    public start(): Promise<void>;\r\n    public start(transferFormat: TransferFormat): Promise<void>;\r\n    public async start(transferFormat?: TransferFormat): Promise<void> {\r\n        transferFormat = transferFormat || TransferFormat.Binary;\r\n\r\n        Arg.isIn(transferFormat, TransferFormat, \"transferFormat\");\r\n\r\n        this.logger.log(LogLevel.Debug, `Starting connection with transfer format '${TransferFormat[transferFormat]}'.`);\r\n\r\n        if (this.connectionState !== ConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start an HttpConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this.connectionState = ConnectionState.Connecting;\r\n\r\n        this.startInternalPromise = this.startInternal(transferFormat);\r\n        await this.startInternalPromise;\r\n\r\n        // The TypeScript compiler thinks that connectionState must be Connecting here. The TypeScript compiler is wrong.\r\n        if (this.connectionState as any === ConnectionState.Disconnecting) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"Failed to start the HttpConnection before stop() was called.\";\r\n            this.logger.log(LogLevel.Error, message);\r\n\r\n            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.\r\n            await this.stopPromise;\r\n\r\n            return Promise.reject(new Error(message));\r\n        } else if (this.connectionState as any !== ConnectionState.Connected) {\r\n            // stop() was called and transitioned the client into the Disconnecting state.\r\n            const message = \"HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!\";\r\n            this.logger.log(LogLevel.Error, message);\r\n            return Promise.reject(new Error(message));\r\n        }\r\n\r\n        this.connectionStarted = true;\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        if (this.connectionState !== ConnectionState.Connected) {\r\n            return Promise.reject(new Error(\"Cannot send data if the connection is not in the 'Connected' State.\"));\r\n        }\r\n\r\n        if (!this.sendQueue) {\r\n            this.sendQueue = new TransportSendQueue(this.transport!);\r\n        }\r\n\r\n        // Transport will not be null if state is connected\r\n        return this.sendQueue.send(data);\r\n    }\r\n\r\n    public async stop(error?: Error): Promise<void> {\r\n        if (this.connectionState === ConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this.connectionState === ConnectionState.Disconnecting) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this.stopPromise;\r\n        }\r\n\r\n        this.connectionState = ConnectionState.Disconnecting;\r\n\r\n        this.stopPromise = new Promise((resolve) => {\r\n            // Don't complete stop() until stopConnection() completes.\r\n            this.stopPromiseResolver = resolve;\r\n        });\r\n\r\n        // stopInternal should never throw so just observe it.\r\n        await this.stopInternal(error);\r\n        await this.stopPromise;\r\n    }\r\n\r\n    private async stopInternal(error?: Error): Promise<void> {\r\n        // Set error as soon as possible otherwise there is a race between\r\n        // the transport closing and providing an error and the error from a close message\r\n        // We would prefer the close message error.\r\n        this.stopError = error;\r\n\r\n        try {\r\n            await this.startInternalPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n\r\n        // The transport's onclose will trigger stopConnection which will run our onclose event.\r\n        // The transport should always be set if currently connected. If it wasn't set, it's likely because\r\n        // stop was called during start() and start() failed.\r\n        if (this.transport) {\r\n            try {\r\n                await this.transport.stop();\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `HttpConnection.transport.stop() threw error '${e}'.`);\r\n                this.stopConnection();\r\n            }\r\n\r\n            this.transport = undefined;\r\n        } else {\r\n            this.logger.log(LogLevel.Debug, \"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.\");\r\n        }\r\n    }\r\n\r\n    private async startInternal(transferFormat: TransferFormat): Promise<void> {\r\n        // Store the original base url and the access token factory since they may change\r\n        // as part of negotiating\r\n        let url = this.baseUrl;\r\n        this.accessTokenFactory = this.options.accessTokenFactory;\r\n\r\n        try {\r\n            if (this.options.skipNegotiation) {\r\n                if (this.options.transport === HttpTransportType.WebSockets) {\r\n                    // No need to add a connection ID in this case\r\n                    this.transport = this.constructTransport(HttpTransportType.WebSockets);\r\n                    // We should just call connect directly in this case.\r\n                    // No fallback or negotiate in this case.\r\n                    await this.startTransport(url, transferFormat);\r\n                } else {\r\n                    throw new Error(\"Negotiation can only be skipped when using the WebSocket transport directly.\");\r\n                }\r\n            } else {\r\n                let negotiateResponse: INegotiateResponse | null = null;\r\n                let redirects = 0;\r\n\r\n                do {\r\n                    negotiateResponse = await this.getNegotiationResponse(url);\r\n                    // the user tries to stop the connection when it is being started\r\n                    if (this.connectionState === ConnectionState.Disconnecting || this.connectionState === ConnectionState.Disconnected) {\r\n                        throw new Error(\"The connection was stopped during negotiation.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.error) {\r\n                        throw new Error(negotiateResponse.error);\r\n                    }\r\n\r\n                    if ((negotiateResponse as any).ProtocolVersion) {\r\n                        throw new Error(\"Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.\");\r\n                    }\r\n\r\n                    if (negotiateResponse.url) {\r\n                        url = negotiateResponse.url;\r\n                    }\r\n\r\n                    if (negotiateResponse.accessToken) {\r\n                        // Replace the current access token factory with one that uses\r\n                        // the returned access token\r\n                        const accessToken = negotiateResponse.accessToken;\r\n                        this.accessTokenFactory = () => accessToken;\r\n                    }\r\n\r\n                    redirects++;\r\n                }\r\n                while (negotiateResponse.url && redirects < MAX_REDIRECTS);\r\n\r\n                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {\r\n                    throw new Error(\"Negotiate redirection limit exceeded.\");\r\n                }\r\n\r\n                await this.createTransport(url, this.options.transport, negotiateResponse, transferFormat);\r\n            }\r\n\r\n            if (this.transport instanceof LongPollingTransport) {\r\n                this.features.inherentKeepAlive = true;\r\n            }\r\n\r\n            if (this.connectionState === ConnectionState.Connecting) {\r\n                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.\r\n                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.\r\n                this.logger.log(LogLevel.Debug, \"The HttpConnection connected successfully.\");\r\n                this.connectionState = ConnectionState.Connected;\r\n            }\r\n\r\n            // stop() is waiting on us via this.startInternalPromise so keep this.transport around so it can clean up.\r\n            // This is the only case startInternal can exit in neither the connected nor disconnected state because stopConnection()\r\n            // will transition to the disconnected state. start() will wait for the transition using the stopPromise.\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, \"Failed to start the connection: \" + e);\r\n            this.connectionState = ConnectionState.Disconnected;\r\n            this.transport = undefined;\r\n\r\n            // if start fails, any active calls to stop assume that start will complete the stop promise\r\n            this.stopPromiseResolver();\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async getNegotiationResponse(url: string): Promise<INegotiateResponse> {\r\n        const headers = {};\r\n        if (this.accessTokenFactory) {\r\n            const token = await this.accessTokenFactory();\r\n            if (token) {\r\n                headers[`Authorization`] = `Bearer ${token}`;\r\n            }\r\n        }\r\n\r\n        const [name, value] = getUserAgentHeader();\r\n        headers[name] = value;\r\n\r\n        const negotiateUrl = this.resolveNegotiateUrl(url);\r\n        this.logger.log(LogLevel.Debug, `Sending negotiation request: ${negotiateUrl}.`);\r\n        try {\r\n            const response = await this.httpClient.post(negotiateUrl, {\r\n                content: \"\",\r\n                headers: { ...headers, ...this.options.headers },\r\n                withCredentials: this.options.withCredentials,\r\n            });\r\n\r\n            if (response.statusCode !== 200) {\r\n                return Promise.reject(new Error(`Unexpected status code returned from negotiate '${response.statusCode}'`));\r\n            }\r\n\r\n            const negotiateResponse = JSON.parse(response.content as string) as INegotiateResponse;\r\n            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {\r\n                // Negotiate version 0 doesn't use connectionToken\r\n                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version\r\n                negotiateResponse.connectionToken = negotiateResponse.connectionId;\r\n            }\r\n            return negotiateResponse;\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, \"Failed to complete negotiation with the server: \" + e);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private createConnectUrl(url: string, connectionToken: string | null | undefined) {\r\n        if (!connectionToken) {\r\n            return url;\r\n        }\r\n\r\n        return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + `id=${connectionToken}`;\r\n    }\r\n\r\n    private async createTransport(url: string, requestedTransport: HttpTransportType | ITransport | undefined, negotiateResponse: INegotiateResponse, requestedTransferFormat: TransferFormat): Promise<void> {\r\n        let connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);\r\n        if (this.isITransport(requestedTransport)) {\r\n            this.logger.log(LogLevel.Debug, \"Connection was provided an instance of ITransport, using that directly.\");\r\n            this.transport = requestedTransport;\r\n            await this.startTransport(connectUrl, requestedTransferFormat);\r\n\r\n            this.connectionId = negotiateResponse.connectionId;\r\n            return;\r\n        }\r\n\r\n        const transportExceptions: any[] = [];\r\n        const transports = negotiateResponse.availableTransports || [];\r\n        let negotiate: INegotiateResponse | undefined = negotiateResponse;\r\n        for (const endpoint of transports) {\r\n            const transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);\r\n            if (transportOrError instanceof Error) {\r\n                // Store the error and continue, we don't want to cause a re-negotiate in these cases\r\n                transportExceptions.push(`${endpoint.transport} failed: ${transportOrError}`);\r\n            } else if (this.isITransport(transportOrError)) {\r\n                this.transport = transportOrError;\r\n                if (!negotiate) {\r\n                    try {\r\n                        negotiate = await this.getNegotiationResponse(url);\r\n                    } catch (ex) {\r\n                        return Promise.reject(ex);\r\n                    }\r\n                    connectUrl = this.createConnectUrl(url, negotiate.connectionToken);\r\n                }\r\n                try {\r\n                    await this.startTransport(connectUrl, requestedTransferFormat);\r\n                    this.connectionId = negotiate.connectionId;\r\n                    return;\r\n                } catch (ex) {\r\n                    this.logger.log(LogLevel.Error, `Failed to start the transport '${endpoint.transport}': ${ex}`);\r\n                    negotiate = undefined;\r\n                    transportExceptions.push(`${endpoint.transport} failed: ${ex}`);\r\n\r\n                    if (this.connectionState !== ConnectionState.Connecting) {\r\n                        const message = \"Failed to select transport before stop() was called.\";\r\n                        this.logger.log(LogLevel.Debug, message);\r\n                        return Promise.reject(new Error(message));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (transportExceptions.length > 0) {\r\n            return Promise.reject(new Error(`Unable to connect to the server with any of the available transports. ${transportExceptions.join(\" \")}`));\r\n        }\r\n        return Promise.reject(new Error(\"None of the transports supported by the client are supported by the server.\"));\r\n    }\r\n\r\n    private constructTransport(transport: HttpTransportType): ITransport {\r\n        switch (transport) {\r\n            case HttpTransportType.WebSockets:\r\n                if (!this.options.WebSocket) {\r\n                    throw new Error(\"'WebSocket' is not supported in your environment.\");\r\n                }\r\n                return new WebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket, this.options.headers || {});\r\n            case HttpTransportType.ServerSentEvents:\r\n                if (!this.options.EventSource) {\r\n                    throw new Error(\"'EventSource' is not supported in your environment.\");\r\n                }\r\n                return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource, this.options.withCredentials!, this.options.headers || {});\r\n            case HttpTransportType.LongPolling:\r\n                return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.withCredentials!, this.options.headers || {});\r\n            default:\r\n                throw new Error(`Unknown transport: ${transport}.`);\r\n        }\r\n    }\r\n\r\n    private startTransport(url: string, transferFormat: TransferFormat): Promise<void> {\r\n        this.transport!.onreceive = this.onreceive;\r\n        this.transport!.onclose = (e) => this.stopConnection(e);\r\n        return this.transport!.connect(url, transferFormat);\r\n    }\r\n\r\n    private resolveTransportOrError(endpoint: IAvailableTransport, requestedTransport: HttpTransportType | undefined, requestedTransferFormat: TransferFormat): ITransport | Error {\r\n        const transport = HttpTransportType[endpoint.transport];\r\n        if (transport === null || transport === undefined) {\r\n            this.logger.log(LogLevel.Debug, `Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n            return new Error(`Skipping transport '${endpoint.transport}' because it is not supported by this client.`);\r\n        } else {\r\n            if (transportMatches(requestedTransport, transport)) {\r\n                const transferFormats = endpoint.transferFormats.map((s) => TransferFormat[s]);\r\n                if (transferFormats.indexOf(requestedTransferFormat) >= 0) {\r\n                    if ((transport === HttpTransportType.WebSockets && !this.options.WebSocket) ||\r\n                        (transport === HttpTransportType.ServerSentEvents && !this.options.EventSource)) {\r\n                        this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it is not supported in your environment.'`);\r\n                        return new Error(`'${HttpTransportType[transport]}' is not supported in your environment.`);\r\n                    } else {\r\n                        this.logger.log(LogLevel.Debug, `Selecting transport '${HttpTransportType[transport]}'.`);\r\n                        try {\r\n                            return this.constructTransport(transport);\r\n                        } catch (ex) {\r\n                            return ex;\r\n                        }\r\n                    }\r\n                } else {\r\n                    this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it does not support the requested transfer format '${TransferFormat[requestedTransferFormat]}'.`);\r\n                    return new Error(`'${HttpTransportType[transport]}' does not support ${TransferFormat[requestedTransferFormat]}.`);\r\n                }\r\n            } else {\r\n                this.logger.log(LogLevel.Debug, `Skipping transport '${HttpTransportType[transport]}' because it was disabled by the client.`);\r\n                return new Error(`'${HttpTransportType[transport]}' is disabled by the client.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private isITransport(transport: any): transport is ITransport {\r\n        return transport && typeof (transport) === \"object\" && \"connect\" in transport;\r\n    }\r\n\r\n    private stopConnection(error?: Error): void {\r\n        this.logger.log(LogLevel.Debug, `HttpConnection.stopConnection(${error}) called while in state ${this.connectionState}.`);\r\n\r\n        this.transport = undefined;\r\n\r\n        // If we have a stopError, it takes precedence over the error from the transport\r\n        error = this.stopError || error;\r\n        this.stopError = undefined;\r\n\r\n        if (this.connectionState === ConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is already in the disconnected state.`);\r\n            return;\r\n        }\r\n\r\n        if (this.connectionState === ConnectionState.Connecting) {\r\n            this.logger.log(LogLevel.Warning, `Call to HttpConnection.stopConnection(${error}) was ignored because the connection is still in the connecting state.`);\r\n            throw new Error(`HttpConnection.stopConnection(${error}) was called while the connection is still in the connecting state.`);\r\n        }\r\n\r\n        if (this.connectionState === ConnectionState.Disconnecting) {\r\n            // A call to stop() induced this call to stopConnection and needs to be completed.\r\n            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.\r\n            this.stopPromiseResolver();\r\n        }\r\n\r\n        if (error) {\r\n            this.logger.log(LogLevel.Error, `Connection disconnected with error '${error}'.`);\r\n        } else {\r\n            this.logger.log(LogLevel.Information, \"Connection disconnected.\");\r\n        }\r\n\r\n        if (this.sendQueue) {\r\n            this.sendQueue.stop().catch((e) => {\r\n                this.logger.log(LogLevel.Error, `TransportSendQueue.stop() threw error '${e}'.`);\r\n            });\r\n            this.sendQueue = undefined;\r\n        }\r\n\r\n        this.connectionId = undefined;\r\n        this.connectionState = ConnectionState.Disconnected;\r\n\r\n        if (this.connectionStarted) {\r\n            this.connectionStarted = false;\r\n            try {\r\n                if (this.onclose) {\r\n                    this.onclose(error);\r\n                }\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `HttpConnection.onclose(${error}) threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private resolveUrl(url: string): string {\r\n        // startsWith is not supported in IE\r\n        if (url.lastIndexOf(\"https://\", 0) === 0 || url.lastIndexOf(\"http://\", 0) === 0) {\r\n            return url;\r\n        }\r\n\r\n        if (!Platform.isBrowser || !window.document) {\r\n            throw new Error(`Cannot resolve '${url}'.`);\r\n        }\r\n\r\n        // Setting the url to the href propery of an anchor tag handles normalization\r\n        // for us. There are 3 main cases.\r\n        // 1. Relative path normalization e.g \"b\" -> \"http://localhost:5000/a/b\"\r\n        // 2. Absolute path normalization e.g \"/a/b\" -> \"http://localhost:5000/a/b\"\r\n        // 3. Networkpath reference normalization e.g \"//localhost:5000/a/b\" -> \"http://localhost:5000/a/b\"\r\n        const aTag = window.document.createElement(\"a\");\r\n        aTag.href = url;\r\n\r\n        this.logger.log(LogLevel.Information, `Normalizing '${url}' to '${aTag.href}'.`);\r\n        return aTag.href;\r\n    }\r\n\r\n    private resolveNegotiateUrl(url: string): string {\r\n        const index = url.indexOf(\"?\");\r\n        let negotiateUrl = url.substring(0, index === -1 ? url.length : index);\r\n        if (negotiateUrl[negotiateUrl.length - 1] !== \"/\") {\r\n            negotiateUrl += \"/\";\r\n        }\r\n        negotiateUrl += \"negotiate\";\r\n        negotiateUrl += index === -1 ? \"\" : url.substring(index);\r\n\r\n        if (negotiateUrl.indexOf(\"negotiateVersion\") === -1) {\r\n            negotiateUrl += index === -1 ? \"?\" : \"&\";\r\n            negotiateUrl += \"negotiateVersion=\" + this.negotiateVersion;\r\n        }\r\n        return negotiateUrl;\r\n    }\r\n}\r\n\r\nfunction transportMatches(requestedTransport: HttpTransportType | undefined, actualTransport: HttpTransportType) {\r\n    return !requestedTransport || ((actualTransport & requestedTransport) !== 0);\r\n}\r\n\r\n/** @private */\r\nexport class TransportSendQueue {\r\n    private buffer: any[] = [];\r\n    private sendBufferedData: PromiseSource;\r\n    private executing: boolean = true;\r\n    private transportResult?: PromiseSource;\r\n    private sendLoopPromise: Promise<void>;\r\n\r\n    constructor(private readonly transport: ITransport) {\r\n        this.sendBufferedData = new PromiseSource();\r\n        this.transportResult = new PromiseSource();\r\n\r\n        this.sendLoopPromise = this.sendLoop();\r\n    }\r\n\r\n    public send(data: string | ArrayBuffer): Promise<void> {\r\n        this.bufferData(data);\r\n        if (!this.transportResult) {\r\n            this.transportResult = new PromiseSource();\r\n        }\r\n        return this.transportResult.promise;\r\n    }\r\n\r\n    public stop(): Promise<void> {\r\n        this.executing = false;\r\n        this.sendBufferedData.resolve();\r\n        return this.sendLoopPromise;\r\n    }\r\n\r\n    private bufferData(data: string | ArrayBuffer): void {\r\n        if (this.buffer.length && typeof(this.buffer[0]) !== typeof(data)) {\r\n            throw new Error(`Expected data to be of type ${typeof(this.buffer)} but was of type ${typeof(data)}`);\r\n        }\r\n\r\n        this.buffer.push(data);\r\n        this.sendBufferedData.resolve();\r\n    }\r\n\r\n    private async sendLoop(): Promise<void> {\r\n        while (true) {\r\n            await this.sendBufferedData.promise;\r\n\r\n            if (!this.executing) {\r\n                if (this.transportResult) {\r\n                    this.transportResult.reject(\"Connection stopped.\");\r\n                }\r\n\r\n                break;\r\n            }\r\n\r\n            this.sendBufferedData = new PromiseSource();\r\n\r\n            const transportResult = this.transportResult!;\r\n            this.transportResult = undefined;\r\n\r\n            const data = typeof(this.buffer[0]) === \"string\" ?\r\n                this.buffer.join(\"\") :\r\n                TransportSendQueue.concatBuffers(this.buffer);\r\n\r\n            this.buffer.length = 0;\r\n\r\n            try {\r\n                await this.transport.send(data);\r\n                transportResult.resolve();\r\n            } catch (error) {\r\n                transportResult.reject(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static concatBuffers(arrayBuffers: ArrayBuffer[]): ArrayBuffer {\r\n        const totalLength = arrayBuffers.map((b) => b.byteLength).reduce((a, b) => a + b);\r\n        const result = new Uint8Array(totalLength);\r\n        let offset = 0;\r\n        for (const item of arrayBuffers) {\r\n            result.set(new Uint8Array(item), offset);\r\n            offset += item.byteLength;\r\n        }\r\n\r\n        return result.buffer;\r\n    }\r\n}\r\n\r\nclass PromiseSource {\r\n    private resolver?: () => void;\r\n    private rejecter!: (reason?: any) => void;\r\n    public promise: Promise<void>;\r\n\r\n    constructor() {\r\n        this.promise = new Promise((resolve, reject) => [this.resolver, this.rejecter] = [resolve, reject]);\r\n    }\r\n\r\n    public resolve(): void {\r\n        this.resolver!();\r\n    }\r\n\r\n    public reject(reason?: any): void {\r\n        this.rejecter!(reason);\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}