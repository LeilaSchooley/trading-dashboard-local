{"ast":null,"code":"import React, { Component } from 'react';\n//import SavedStockCache from './main/SavedStockCache.js';\n//import DashboardTwoAlertCache from './DashboardTwo/js/DashboardTwoAlertCache.js';\nimport * as signalR from '@microsoft/signalr'; // Update to microsoft/signalr\nimport * as all from '../src/api/financialApi';\nimport * as connection from './HubConnectionHandler';\nexport class DataFeed extends Component {\n  /*  static hubConnection = new signalR.HubConnectionBuilder()\r\n        .withUrl(\"https://localhost:44362/stockfeed\")\r\n        .withAutomaticReconnect()\r\n        .configureLogging(signalR.LogLevel.Information)\r\n        .build();*/\n\n  constructor(props) {\n    super(props);\n\n    // this.updateCache = false;\n    this.componentDidUpdate = (prevProps, prevState, snapshot) => {};\n    this.lock = false;\n    this.connected = false;\n    this.keyCount = 0;\n    this.updateStockInfo = false;\n    this.state = {\n      stockTableTwo: [],\n      isStreaming: false,\n      lock: false,\n      hubConnection: null,\n      request_Calls: -1,\n      MAX_CALLS: 896,\n      called: true\n    };\n  }\n  componentDidMount() {\n    all.requestPairByDay_(\"gsp\");\n\n    // await connection.start();\n    // console.log('START THE FEED!')\n    //  localStorage.setItem('_connectionEstablished', false);\n    //this.startDataFeed();\n  }\n\n  async connectionTimeout() {\n    var count = 0;\n    return new Promise(resolve => {\n      this.interval = setInterval(() => {\n        // Number of retries allowed: 3\n        if (this.connected == true) {\n          clearInterval(this.interval);\n          resolve(false);\n        } else if (count >= 3) {\n          clearInterval(this.interval);\n          resolve(true);\n        }\n        count++;\n      }, 8000);\n    });\n  }\n\n  /**\r\n    * Gets the timezone by identifier as\r\n    * well as the total time elapsed, can \r\n    * only be called if a user is logged in \r\n    * and triggers the alert interval, as \r\n    * long as the settings persist before the \r\n    * user logs out\r\n    */\n  async detectTimeZone() {\n    // Fill Cache with EOD data\n    await fetch('detectTimeZone').then(response => response.json()).then(response => {\n      //.set(key, item);\n    }).catch(error => {\n      console.log(\"error \" + error); // 404\n      // Last successfully catched data\n      return;\n    });\n  }\n\n  /* End Of Day Data \r\n  async eodData() {\r\n      // Fill Cache with EOD data\r\n      await fetch('geteod/data')\r\n          .then(response => response.json())\r\n          .then(response => {\r\n              for (var key = 0; key < response.length; key++) {\r\n                  const item = JSON.parse(response[key]);\r\n                    // Scanner\r\n                  ScannerCache.set(key, item);\r\n                    // DashboardTwo \r\n                  DashboardTwoCache.set(key, item);\r\n                  DashboardTwoAlertCache.set(key, item);\r\n                    // Portfolio\r\n                  PortfolioCache.set(key, item);\r\n                  // Set Gross\r\n                    // Historical\r\n                  HistoryCache.set(key, item);\r\n                    // Dashboard One\r\n                  TableCache.set(key, item);\r\n                  AlertCache.set(key, item);\r\n                  SavedStockCache.set(key, item);\r\n              }\r\n          })\r\n          .catch(error => {\r\n              console.log(\"error \" + error) // 404\r\n              // Last successfully catched data\r\n              return;\r\n          }\r\n          );\r\n  }*/\n\n  /**\r\n   * Starts the data feed and subscribes to a method on\r\n   * the server which will retrieve the data. All Caches will\r\n   * be populated through this method, if there is a faliure\r\n   * the caches will be populated with the last successfully\r\n   * fetched data, or EOD data when the session ends.\r\n   */\n  async startDataFeed() {\n    var count = 0;\n\n    // Create a Manager class\n    await DataFeed.hubConnection.start().then(() => {\n      console.log('Successfully connected');\n      DataFeed.hubConnection.on('lockStream', (request_Calls, sessionEnded) => {\n        // Add Timeout\n        this.request_Calls = request_Calls;\n        const exists = localStorage.getItem('sessionEnded');\n        if (exists === null || exists === undefined) {\n          localStorage.setItem('sessionEnded', sessionEnded);\n        } else if (exists !== sessionEnded) {\n          localStorage.removeItem('sessionEnded');\n          localStorage.setItem('sessionEnded', sessionEnded);\n        }\n        if (sessionEnded) {\n          localStorage.setItem('sessionEndedCalled', false);\n          this.eodData(); // EOD data\n        }\n      });\n\n      DataFeed.hubConnection.on('requestData', (key, data) => {\n        const item = JSON.parse(data);\n\n        // Scanner\n        /* ScannerCache.set(key, item);\r\n           // DashboardTwo \r\n         DashboardTwoCache.set(key, item);\r\n         DashboardTwoAlertCache.set(key, item);\r\n           // Portfolio\r\n         PortfolioCache.set(key, item);\r\n           // Historical\r\n         HistoryCache.set(key, item);\r\n           // Dashboard One\r\n         TableCache.set(key, item);\r\n         AlertCache.set(key, item);\r\n         SavedStockCache.set(key, item);\r\n           if (!this.state.updateCache)\r\n             this.setState({ updateCache: false });\r\n           if (count < 897) {\r\n             count += 1;\r\n         }\r\n         else {\r\n             count = 0;\r\n             console.log(\"Ok\")\r\n             //   PortfolioCache.updateDataCallback(); // Updates data in portfolioo\r\n             TableCache.setFill(true);\r\n             DashboardTwoCache.setFill(true);\r\n             this.setState({ updateCache: true });\r\n             this.connected = true;\r\n         }*/\n      });\n    }) // Bind to constructor\n    .catch(err => {\n      console.log('Error while establishing hubConnection :( ' + err);\n      this.eodData();\n      this.connected = false;\n    }); // Redirect to 404 page\n\n    const res = await this.connectionTimeout();\n    this.props.getUpdateCache(!res);\n    this.setState({\n      ...this.state,\n      updateCache: !res,\n      lock: res\n    });\n    localStorage.setItem('_connectionEstablished', !res);\n  }\n  render() {\n    return null;\n  }\n}","map":{"version":3,"names":["React","Component","signalR","all","connection","DataFeed","constructor","props","componentDidUpdate","prevProps","prevState","snapshot","lock","connected","keyCount","updateStockInfo","state","stockTableTwo","isStreaming","hubConnection","request_Calls","MAX_CALLS","called","componentDidMount","requestPairByDay_","connectionTimeout","count","Promise","resolve","interval","setInterval","clearInterval","detectTimeZone","fetch","then","response","json","catch","error","console","log","startDataFeed","start","on","sessionEnded","exists","localStorage","getItem","undefined","setItem","removeItem","eodData","key","data","item","JSON","parse","err","res","getUpdateCache","setState","updateCache","render"],"sources":["C:/Users/badsc/Documents/GitHub/trading-dashboard-local/src/DataFeed.js"],"sourcesContent":["import React, { Component } from 'react';\r\n//import SavedStockCache from './main/SavedStockCache.js';\r\n//import DashboardTwoAlertCache from './DashboardTwo/js/DashboardTwoAlertCache.js';\r\nimport * as signalR from '@microsoft/signalr'; // Update to microsoft/signalr\r\nimport * as all from '../src/api/financialApi';\r\nimport * as connection from './HubConnectionHandler';\r\nexport class DataFeed extends Component {\r\n  /*  static hubConnection = new signalR.HubConnectionBuilder()\r\n        .withUrl(\"https://localhost:44362/stockfeed\")\r\n        .withAutomaticReconnect()\r\n        .configureLogging(signalR.LogLevel.Information)\r\n        .build();*/\r\n\r\n    \r\n    constructor(props) {\r\n        super(props);\r\n\r\n        // this.updateCache = false;\r\n        this.lock = false;\r\n        this.connected = false;\r\n        this.keyCount = 0;\r\n        this.updateStockInfo = false;\r\n\r\n        this.state = {\r\n            stockTableTwo: [],\r\n            isStreaming: false,\r\n            lock: false,\r\n            hubConnection: null,\r\n            request_Calls: -1,\r\n            MAX_CALLS: 896,\r\n            called: true,\r\n        };\r\n    }\r\n\r\n    componentDidMount() {\r\n      all.requestPairByDay_(\"gsp\");\r\n       \r\n       // await connection.start();\r\n        // console.log('START THE FEED!')\r\n      //  localStorage.setItem('_connectionEstablished', false);\r\n        //this.startDataFeed();\r\n    }\r\n\r\n    componentDidUpdate = (prevProps, prevState, snapshot) => {\r\n\r\n    }\r\n\r\n   \r\n\r\n    async connectionTimeout() {\r\n        var count = 0;\r\n\r\n        return new Promise(resolve => {\r\n            this.interval = setInterval(() => {\r\n                // Number of retries allowed: 3\r\n                if (this.connected == true) {\r\n                    clearInterval(this.interval)\r\n                    resolve(false)\r\n                }\r\n                else if (count >= 3) {\r\n                    clearInterval(this.interval)\r\n                    resolve(true)\r\n                }\r\n                count++;\r\n            }, 8000);\r\n        });\r\n    }\r\n\r\n    /**\r\n      * Gets the timezone by identifier as\r\n      * well as the total time elapsed, can \r\n      * only be called if a user is logged in \r\n      * and triggers the alert interval, as \r\n      * long as the settings persist before the \r\n      * user logs out\r\n      */\r\n    async detectTimeZone() {\r\n        // Fill Cache with EOD data\r\n        await fetch('detectTimeZone')\r\n            .then(response => response.json())\r\n            .then(response => {\r\n                //.set(key, item);\r\n            })\r\n            .catch(error => {\r\n                console.log(\"error \" + error) // 404\r\n                // Last successfully catched data\r\n                return;\r\n            }\r\n            );\r\n    }\r\n\r\n    /* End Of Day Data \r\n    async eodData() {\r\n        // Fill Cache with EOD data\r\n        await fetch('geteod/data')\r\n            .then(response => response.json())\r\n            .then(response => {\r\n                for (var key = 0; key < response.length; key++) {\r\n                    const item = JSON.parse(response[key]);\r\n\r\n                    // Scanner\r\n                    ScannerCache.set(key, item);\r\n\r\n                    // DashboardTwo \r\n                    DashboardTwoCache.set(key, item);\r\n                    DashboardTwoAlertCache.set(key, item);\r\n\r\n                    // Portfolio\r\n                    PortfolioCache.set(key, item);\r\n                    // Set Gross\r\n\r\n                    // Historical\r\n                    HistoryCache.set(key, item);\r\n\r\n                    // Dashboard One\r\n                    TableCache.set(key, item);\r\n                    AlertCache.set(key, item);\r\n                    SavedStockCache.set(key, item);\r\n                }\r\n            })\r\n            .catch(error => {\r\n                console.log(\"error \" + error) // 404\r\n                // Last successfully catched data\r\n                return;\r\n            }\r\n            );\r\n    }*/\r\n\r\n    /**\r\n     * Starts the data feed and subscribes to a method on\r\n     * the server which will retrieve the data. All Caches will\r\n     * be populated through this method, if there is a faliure\r\n     * the caches will be populated with the last successfully\r\n     * fetched data, or EOD data when the session ends.\r\n     */\r\n    async startDataFeed() {\r\n        var count = 0;\r\n        \r\n        // Create a Manager class\r\n        await DataFeed.hubConnection\r\n            .start()\r\n            .then(() => {\r\n                console.log('Successfully connected');\r\n                DataFeed.hubConnection.on('lockStream', (request_Calls, sessionEnded) => {\r\n                    // Add Timeout\r\n                    this.request_Calls = request_Calls;\r\n\r\n                    const exists = localStorage.getItem('sessionEnded')\r\n                    if (exists === null || exists === undefined) {\r\n                        localStorage.setItem('sessionEnded', sessionEnded);\r\n                    }\r\n                    else if (exists !== sessionEnded) {\r\n                        localStorage.removeItem('sessionEnded');\r\n                        localStorage.setItem('sessionEnded', sessionEnded)\r\n                    }\r\n\r\n                    if (sessionEnded) {\r\n                        localStorage.setItem('sessionEndedCalled', false);\r\n                        this.eodData(); // EOD data\r\n                    }\r\n                })\r\n                DataFeed.hubConnection.on('requestData', (key, data) => {\r\n                    const item = JSON.parse(data);\r\n\r\n                    // Scanner\r\n                   /* ScannerCache.set(key, item);\r\n\r\n                    // DashboardTwo \r\n                    DashboardTwoCache.set(key, item);\r\n                    DashboardTwoAlertCache.set(key, item);\r\n\r\n                    // Portfolio\r\n                    PortfolioCache.set(key, item);\r\n\r\n                    // Historical\r\n                    HistoryCache.set(key, item);\r\n\r\n                    // Dashboard One\r\n                    TableCache.set(key, item);\r\n                    AlertCache.set(key, item);\r\n                    SavedStockCache.set(key, item);\r\n\r\n                    if (!this.state.updateCache)\r\n                        this.setState({ updateCache: false });\r\n\r\n                    if (count < 897) {\r\n                        count += 1;\r\n                    }\r\n                    else {\r\n                        count = 0;\r\n                        console.log(\"Ok\")\r\n                        //   PortfolioCache.updateDataCallback(); // Updates data in portfolioo\r\n                        TableCache.setFill(true);\r\n                        DashboardTwoCache.setFill(true);\r\n                        this.setState({ updateCache: true });\r\n                        this.connected = true;\r\n                    }*/\r\n                })\r\n            }) // Bind to constructor\r\n            .catch(err => {\r\n                console.log('Error while establishing hubConnection :( ' + err)\r\n                this.eodData();\r\n                this.connected = false;\r\n            }); // Redirect to 404 page\r\n\r\n        const res = await this.connectionTimeout();\r\n        this.props.getUpdateCache(!res);\r\n        this.setState({ ...this.state, updateCache: !res, lock: res });\r\n        localStorage.setItem('_connectionEstablished', !res);\r\n    }\r\n\r\n    render() {\r\n        return null;\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}