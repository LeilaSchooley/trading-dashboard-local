{"ast":null,"code":"var _classCallCheck = require(\"C:\\\\Users\\\\badsc\\\\Documents\\\\GitHub\\\\trading-dashboard-local\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\nvar _createClass = require(\"C:\\\\Users\\\\badsc\\\\Documents\\\\GitHub\\\\trading-dashboard-local\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\nvar _slicedToArray = require(\"C:\\\\Users\\\\badsc\\\\Documents\\\\GitHub\\\\trading-dashboard-local\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"_log\"] }] */\n\nvar debug = require('debug')('log4js:logger');\nvar LoggingEvent = require('./LoggingEvent');\nvar levels = require('./levels');\nvar clustering = require('./clustering');\nvar categories = require('./categories');\nvar configuration = require('./configuration');\nvar stackReg = /^(?:\\s*)at (?:(.+) \\()?(?:([^(]+?):(\\d+):(\\d+))\\)?$/;\n/**\n * The top entry is the Error\n */\nvar baseCallStackSkip = 1;\n/**\n * The _log function is 3 levels deep, we need to skip those to make it to the callSite\n */\nvar defaultErrorCallStackSkip = 3;\n\n/**\n *\n * @param {Error} data\n * @param {number} skipIdx\n * @returns {import('../types/log4js').CallStack | null}\n */\nfunction defaultParseCallStack(data) {\n  var skipIdx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultErrorCallStackSkip + baseCallStackSkip;\n  try {\n    var stacklines = data.stack.split('\\n').slice(skipIdx);\n    if (!stacklines.length) {\n      // There's no stack in this stack\n      // Should we try a previous index if skipIdx was set?\n      return null;\n    }\n    var lineMatch = stackReg.exec(stacklines[0]);\n    /* istanbul ignore else: failsafe */\n    if (lineMatch && lineMatch.length === 5) {\n      // extract class, function and alias names\n      var className = '';\n      var functionName = '';\n      var functionAlias = '';\n      if (lineMatch[1] && lineMatch[1] !== '') {\n        // WARN: this will unset alias if alias is not present.\n        var _lineMatch$1$replace$ = lineMatch[1].replace(/[[\\]]/g, '').split(' as ');\n        var _lineMatch$1$replace$2 = _slicedToArray(_lineMatch$1$replace$, 2);\n        functionName = _lineMatch$1$replace$2[0];\n        functionAlias = _lineMatch$1$replace$2[1];\n        functionAlias = functionAlias || '';\n        if (functionName.includes('.')) {\n          var _functionName$split = functionName.split('.');\n          var _functionName$split2 = _slicedToArray(_functionName$split, 2);\n          className = _functionName$split2[0];\n          functionName = _functionName$split2[1];\n        }\n      }\n      return {\n        fileName: lineMatch[2],\n        lineNumber: parseInt(lineMatch[3], 10),\n        columnNumber: parseInt(lineMatch[4], 10),\n        callStack: stacklines.join('\\n'),\n        className: className,\n        functionName: functionName,\n        functionAlias: functionAlias,\n        callerName: lineMatch[1] || ''\n      };\n      // eslint-disable-next-line no-else-return\n    } else {\n      // will never get here unless nodejs has changes to Error\n      console.error('log4js.logger - defaultParseCallStack error'); // eslint-disable-line no-console\n    }\n  } catch (err) {\n    // will never get error unless nodejs has breaking changes to Error\n    console.error('log4js.logger - defaultParseCallStack error', err); // eslint-disable-line no-console\n  }\n\n  return null;\n}\n\n/**\n * Logger to log messages.\n * use {@see log4js#getLogger(String)} to get an instance.\n *\n * @name Logger\n * @namespace Log4js\n * @param name name of category to log to\n * @param level - the loglevel for the category\n * @param dispatch - the function which will receive the logevents\n *\n * @author Stephan Strittmatter\n */\nvar Logger = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Logger(name) {\n    _classCallCheck(this, Logger);\n    if (!name) {\n      throw new Error('No category provided.');\n    }\n    this.category = name;\n    this.context = {};\n    /** @private */\n    this.callStackSkipIndex = 0;\n    /** @private */\n    this.parseCallStack = defaultParseCallStack;\n    debug(\"Logger created (\".concat(this.category, \", \").concat(this.level, \")\"));\n  }\n  _createClass(Logger, [{\n    key: \"level\",\n    get: function get() {\n      return levels.getLevel(categories.getLevelForCategory(this.category), levels.OFF);\n    },\n    set: function set(level) {\n      categories.setLevelForCategory(this.category, levels.getLevel(level, this.level));\n    }\n  }, {\n    key: \"useCallStack\",\n    get: function get() {\n      return categories.getEnableCallStackForCategory(this.category);\n    },\n    set: function set(bool) {\n      categories.setEnableCallStackForCategory(this.category, bool === true);\n    }\n  }, {\n    key: \"callStackLinesToSkip\",\n    get: function get() {\n      return this.callStackSkipIndex;\n    },\n    set: function set(number) {\n      if (typeof number !== 'number') {\n        throw new TypeError('Must be a number');\n      }\n      if (number < 0) {\n        throw new RangeError('Must be >= 0');\n      }\n      this.callStackSkipIndex = number;\n    }\n  }, {\n    key: \"log\",\n    value: function log(level) {\n      var logLevel = levels.getLevel(level);\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      if (!logLevel) {\n        if (configuration.validIdentifier(level) && args.length > 0) {\n          // logLevel not found but of valid signature, WARN before fallback to INFO\n          this.log(levels.WARN, 'log4js:logger.log: valid log-level not found as first parameter given:', level);\n          this.log.apply(this, [levels.INFO, \"[\".concat(level, \"]\")].concat(args));\n        } else {\n          // apart from fallback, allow .log(...args) to be synonym with .log(\"INFO\", ...args)\n          this.log.apply(this, [levels.INFO, level].concat(args));\n        }\n      } else if (this.isLevelEnabled(logLevel)) {\n        this._log(logLevel, args);\n      }\n    }\n  }, {\n    key: \"isLevelEnabled\",\n    value: function isLevelEnabled(otherLevel) {\n      return this.level.isLessThanOrEqualTo(otherLevel);\n    }\n  }, {\n    key: \"_log\",\n    value: function _log(level, data) {\n      debug(\"sending log data (\".concat(level, \") to appenders\"));\n      var error = data.find(function (item) {\n        return item instanceof Error;\n      });\n      var callStack;\n      if (this.useCallStack) {\n        try {\n          if (error) {\n            callStack = this.parseCallStack(error, this.callStackSkipIndex + baseCallStackSkip);\n          }\n        } catch (_err) {\n          // Ignore Error and use the original method of creating a new Error.\n        }\n        callStack = callStack || this.parseCallStack(new Error(), this.callStackSkipIndex + defaultErrorCallStackSkip + baseCallStackSkip);\n      }\n      var loggingEvent = new LoggingEvent(this.category, level, data, this.context, callStack, error);\n      clustering.send(loggingEvent);\n    }\n  }, {\n    key: \"addContext\",\n    value: function addContext(key, value) {\n      this.context[key] = value;\n    }\n  }, {\n    key: \"removeContext\",\n    value: function removeContext(key) {\n      delete this.context[key];\n    }\n  }, {\n    key: \"clearContext\",\n    value: function clearContext() {\n      this.context = {};\n    }\n  }, {\n    key: \"setParseCallStackFunction\",\n    value: function setParseCallStackFunction(parseFunction) {\n      if (typeof parseFunction === 'function') {\n        this.parseCallStack = parseFunction;\n      } else if (typeof parseFunction === 'undefined') {\n        this.parseCallStack = defaultParseCallStack;\n      } else {\n        throw new TypeError('Invalid type passed to setParseCallStackFunction');\n      }\n    }\n  }]);\n  return Logger;\n}();\nfunction addLevelMethods(target) {\n  var level = levels.getLevel(target);\n  var levelStrLower = level.toString().toLowerCase();\n  var levelMethod = levelStrLower.replace(/_([a-z])/g, function (g) {\n    return g[1].toUpperCase();\n  });\n  var isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);\n  Logger.prototype[\"is\".concat(isLevelMethod, \"Enabled\")] = function () {\n    return this.isLevelEnabled(level);\n  };\n  Logger.prototype[levelMethod] = function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    this.log.apply(this, [level].concat(args));\n  };\n}\nlevels.levels.forEach(addLevelMethods);\nconfiguration.addListener(function () {\n  levels.levels.forEach(addLevelMethods);\n});\nmodule.exports = Logger;","map":{"version":3,"names":["debug","require","LoggingEvent","levels","clustering","categories","configuration","stackReg","baseCallStackSkip","defaultErrorCallStackSkip","defaultParseCallStack","data","skipIdx","arguments","length","undefined","stacklines","stack","split","slice","lineMatch","exec","className","functionName","functionAlias","_lineMatch$1$replace$","replace","_lineMatch$1$replace$2","_slicedToArray","includes","_functionName$split","_functionName$split2","fileName","lineNumber","parseInt","columnNumber","callStack","join","callerName","console","error","err","Logger","name","_classCallCheck","Error","category","context","callStackSkipIndex","parseCallStack","concat","level","_createClass","key","get","getLevel","getLevelForCategory","OFF","set","setLevelForCategory","getEnableCallStackForCategory","bool","setEnableCallStackForCategory","number","TypeError","RangeError","value","log","logLevel","_len","args","Array","_key","validIdentifier","WARN","apply","INFO","isLevelEnabled","_log","otherLevel","isLessThanOrEqualTo","find","item","useCallStack","_err","loggingEvent","send","addContext","removeContext","clearContext","setParseCallStackFunction","parseFunction","addLevelMethods","target","levelStrLower","toString","toLowerCase","levelMethod","g","toUpperCase","isLevelMethod","prototype","_len2","_key2","forEach","addListener","module","exports"],"sources":["C:/Users/badsc/Documents/GitHub/trading-dashboard-local/node_modules/log4js/lib/logger.js"],"sourcesContent":["/* eslint no-underscore-dangle: [\"error\", { \"allow\": [\"_log\"] }] */\n\nconst debug = require('debug')('log4js:logger');\nconst LoggingEvent = require('./LoggingEvent');\nconst levels = require('./levels');\nconst clustering = require('./clustering');\nconst categories = require('./categories');\nconst configuration = require('./configuration');\n\nconst stackReg = /^(?:\\s*)at (?:(.+) \\()?(?:([^(]+?):(\\d+):(\\d+))\\)?$/;\n/**\n * The top entry is the Error\n */\nconst baseCallStackSkip = 1;\n/**\n * The _log function is 3 levels deep, we need to skip those to make it to the callSite\n */\nconst defaultErrorCallStackSkip = 3;\n\n/**\n *\n * @param {Error} data\n * @param {number} skipIdx\n * @returns {import('../types/log4js').CallStack | null}\n */\nfunction defaultParseCallStack(\n  data,\n  skipIdx = defaultErrorCallStackSkip + baseCallStackSkip\n) {\n  try {\n    const stacklines = data.stack.split('\\n').slice(skipIdx);\n    if (!stacklines.length) {\n      // There's no stack in this stack\n      // Should we try a previous index if skipIdx was set?\n      return null;\n    }\n    const lineMatch = stackReg.exec(stacklines[0]);\n    /* istanbul ignore else: failsafe */\n    if (lineMatch && lineMatch.length === 5) {\n      // extract class, function and alias names\n      let className = '';\n      let functionName = '';\n      let functionAlias = '';\n      if (lineMatch[1] && lineMatch[1] !== '') {\n        // WARN: this will unset alias if alias is not present.\n        [functionName, functionAlias] = lineMatch[1]\n          .replace(/[[\\]]/g, '')\n          .split(' as ');\n        functionAlias = functionAlias || '';\n\n        if (functionName.includes('.'))\n          [className, functionName] = functionName.split('.');\n      }\n\n      return {\n        fileName: lineMatch[2],\n        lineNumber: parseInt(lineMatch[3], 10),\n        columnNumber: parseInt(lineMatch[4], 10),\n        callStack: stacklines.join('\\n'),\n        className,\n        functionName,\n        functionAlias,\n        callerName: lineMatch[1] || '',\n      };\n      // eslint-disable-next-line no-else-return\n    } else {\n      // will never get here unless nodejs has changes to Error\n      console.error('log4js.logger - defaultParseCallStack error'); // eslint-disable-line no-console\n    }\n  } catch (err) {\n    // will never get error unless nodejs has breaking changes to Error\n    console.error('log4js.logger - defaultParseCallStack error', err); // eslint-disable-line no-console\n  }\n  return null;\n}\n\n/**\n * Logger to log messages.\n * use {@see log4js#getLogger(String)} to get an instance.\n *\n * @name Logger\n * @namespace Log4js\n * @param name name of category to log to\n * @param level - the loglevel for the category\n * @param dispatch - the function which will receive the logevents\n *\n * @author Stephan Strittmatter\n */\nclass Logger {\n  constructor(name) {\n    if (!name) {\n      throw new Error('No category provided.');\n    }\n    this.category = name;\n    this.context = {};\n    /** @private */\n    this.callStackSkipIndex = 0;\n    /** @private */\n    this.parseCallStack = defaultParseCallStack;\n    debug(`Logger created (${this.category}, ${this.level})`);\n  }\n\n  get level() {\n    return levels.getLevel(\n      categories.getLevelForCategory(this.category),\n      levels.OFF\n    );\n  }\n\n  set level(level) {\n    categories.setLevelForCategory(\n      this.category,\n      levels.getLevel(level, this.level)\n    );\n  }\n\n  get useCallStack() {\n    return categories.getEnableCallStackForCategory(this.category);\n  }\n\n  set useCallStack(bool) {\n    categories.setEnableCallStackForCategory(this.category, bool === true);\n  }\n\n  get callStackLinesToSkip() {\n    return this.callStackSkipIndex;\n  }\n\n  set callStackLinesToSkip(number) {\n    if (typeof number !== 'number') {\n      throw new TypeError('Must be a number');\n    }\n    if (number < 0) {\n      throw new RangeError('Must be >= 0');\n    }\n    this.callStackSkipIndex = number;\n  }\n\n  log(level, ...args) {\n    const logLevel = levels.getLevel(level);\n    if (!logLevel) {\n      if (configuration.validIdentifier(level) && args.length > 0) {\n        // logLevel not found but of valid signature, WARN before fallback to INFO\n        this.log(\n          levels.WARN,\n          'log4js:logger.log: valid log-level not found as first parameter given:',\n          level\n        );\n        this.log(levels.INFO, `[${level}]`, ...args);\n      } else {\n        // apart from fallback, allow .log(...args) to be synonym with .log(\"INFO\", ...args)\n        this.log(levels.INFO, level, ...args);\n      }\n    } else if (this.isLevelEnabled(logLevel)) {\n      this._log(logLevel, args);\n    }\n  }\n\n  isLevelEnabled(otherLevel) {\n    return this.level.isLessThanOrEqualTo(otherLevel);\n  }\n\n  _log(level, data) {\n    debug(`sending log data (${level}) to appenders`);\n    const error = data.find((item) => item instanceof Error);\n    let callStack;\n    if (this.useCallStack) {\n      try {\n        if (error) {\n          callStack = this.parseCallStack(\n            error,\n            this.callStackSkipIndex + baseCallStackSkip\n          );\n        }\n      } catch (_err) {\n        // Ignore Error and use the original method of creating a new Error.\n      }\n      callStack =\n        callStack ||\n        this.parseCallStack(\n          new Error(),\n          this.callStackSkipIndex +\n            defaultErrorCallStackSkip +\n            baseCallStackSkip\n        );\n    }\n    const loggingEvent = new LoggingEvent(\n      this.category,\n      level,\n      data,\n      this.context,\n      callStack,\n      error\n    );\n    clustering.send(loggingEvent);\n  }\n\n  addContext(key, value) {\n    this.context[key] = value;\n  }\n\n  removeContext(key) {\n    delete this.context[key];\n  }\n\n  clearContext() {\n    this.context = {};\n  }\n\n  setParseCallStackFunction(parseFunction) {\n    if (typeof parseFunction === 'function') {\n      this.parseCallStack = parseFunction;\n    } else if (typeof parseFunction === 'undefined') {\n      this.parseCallStack = defaultParseCallStack;\n    } else {\n      throw new TypeError('Invalid type passed to setParseCallStackFunction');\n    }\n  }\n}\n\nfunction addLevelMethods(target) {\n  const level = levels.getLevel(target);\n\n  const levelStrLower = level.toString().toLowerCase();\n  const levelMethod = levelStrLower.replace(/_([a-z])/g, (g) =>\n    g[1].toUpperCase()\n  );\n  const isLevelMethod = levelMethod[0].toUpperCase() + levelMethod.slice(1);\n\n  Logger.prototype[`is${isLevelMethod}Enabled`] = function () {\n    return this.isLevelEnabled(level);\n  };\n\n  Logger.prototype[levelMethod] = function (...args) {\n    this.log(level, ...args);\n  };\n}\n\nlevels.levels.forEach(addLevelMethods);\n\nconfiguration.addListener(() => {\n  levels.levels.forEach(addLevelMethods);\n});\n\nmodule.exports = Logger;\n"],"mappings":";;;AAAA;;AAEA,IAAMA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC,CAAC,eAAe,CAAC;AAC/C,IAAMC,YAAY,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAC9C,IAAME,MAAM,GAAGF,OAAO,CAAC,UAAU,CAAC;AAClC,IAAMG,UAAU,GAAGH,OAAO,CAAC,cAAc,CAAC;AAC1C,IAAMI,UAAU,GAAGJ,OAAO,CAAC,cAAc,CAAC;AAC1C,IAAMK,aAAa,GAAGL,OAAO,CAAC,iBAAiB,CAAC;AAEhD,IAAMM,QAAQ,GAAG,qDAAqD;AACtE;AACA;AACA;AACA,IAAMC,iBAAiB,GAAG,CAAC;AAC3B;AACA;AACA;AACA,IAAMC,yBAAyB,GAAG,CAAC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,qBAAqBA,CAC5BC,IAAI,EAEJ;EAAA,IADAC,OAAO,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAGJ,yBAAyB,GAAGD,iBAAiB;EAEvD,IAAI;IACF,IAAMQ,UAAU,GAAGL,IAAI,CAACM,KAAK,CAACC,KAAK,CAAC,IAAI,CAAC,CAACC,KAAK,CAACP,OAAO,CAAC;IACxD,IAAI,CAACI,UAAU,CAACF,MAAM,EAAE;MACtB;MACA;MACA,OAAO,IAAI;IACb;IACA,IAAMM,SAAS,GAAGb,QAAQ,CAACc,IAAI,CAACL,UAAU,CAAC,CAAC,CAAC,CAAC;IAC9C;IACA,IAAII,SAAS,IAAIA,SAAS,CAACN,MAAM,KAAK,CAAC,EAAE;MACvC;MACA,IAAIQ,SAAS,GAAG,EAAE;MAClB,IAAIC,YAAY,GAAG,EAAE;MACrB,IAAIC,aAAa,GAAG,EAAE;MACtB,IAAIJ,SAAS,CAAC,CAAC,CAAC,IAAIA,SAAS,CAAC,CAAC,CAAC,KAAK,EAAE,EAAE;QACvC;QAAA,IAAAK,qBAAA,GACgCL,SAAS,CAAC,CAAC,CAAC,CACzCM,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CACrBR,KAAK,CAAC,MAAM,CAAC;QAAA,IAAAS,sBAAA,GAAAC,cAAA,CAAAH,qBAAA;QAFfF,YAAY,GAAAI,sBAAA;QAAEH,aAAa,GAAAG,sBAAA;QAG5BH,aAAa,GAAGA,aAAa,IAAI,EAAE;QAEnC,IAAID,YAAY,CAACM,QAAQ,CAAC,GAAG,CAAC;UAAA,IAAAC,mBAAA,GACAP,YAAY,CAACL,KAAK,CAAC,GAAG,CAAC;UAAA,IAAAa,oBAAA,GAAAH,cAAA,CAAAE,mBAAA;UAAlDR,SAAS,GAAAS,oBAAA;UAAER,YAAY,GAAAQ,oBAAA;QAAA;MAC5B;MAEA,OAAO;QACLC,QAAQ,EAAEZ,SAAS,CAAC,CAAC,CAAC;QACtBa,UAAU,EAAEC,QAAQ,CAACd,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACtCe,YAAY,EAAED,QAAQ,CAACd,SAAS,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;QACxCgB,SAAS,EAAEpB,UAAU,CAACqB,IAAI,CAAC,IAAI,CAAC;QAChCf,SAAS,EAATA,SAAS;QACTC,YAAY,EAAZA,YAAY;QACZC,aAAa,EAAbA,aAAa;QACbc,UAAU,EAAElB,SAAS,CAAC,CAAC,CAAC,IAAI;MAC9B,CAAC;MACD;IACF,CAAC,MAAM;MACL;MACAmB,OAAO,CAACC,KAAK,CAAC,6CAA6C,CAAC,CAAC,CAAC;IAChE;EACF,CAAC,CAAC,OAAOC,GAAG,EAAE;IACZ;IACAF,OAAO,CAACC,KAAK,CAAC,6CAA6C,EAAEC,GAAG,CAAC,CAAC,CAAC;EACrE;;EACA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA,IAYMC,MAAM;EAAA;;EACV,SAAAA,OAAYC,IAAI,EAAE;IAAAC,eAAA,OAAAF,MAAA;IAChB,IAAI,CAACC,IAAI,EAAE;MACT,MAAM,IAAIE,KAAK,CAAC,uBAAuB,CAAC;IAC1C;IACA,IAAI,CAACC,QAAQ,GAAGH,IAAI;IACpB,IAAI,CAACI,OAAO,GAAG,CAAC,CAAC;IACjB;IACA,IAAI,CAACC,kBAAkB,GAAG,CAAC;IAC3B;IACA,IAAI,CAACC,cAAc,GAAGvC,qBAAqB;IAC3CV,KAAK,oBAAAkD,MAAA,CAAoB,IAAI,CAACJ,QAAQ,QAAAI,MAAA,CAAK,IAAI,CAACC,KAAK,MAAG,CAAC;EAC3D;EAACC,YAAA,CAAAV,MAAA;IAAAW,GAAA;IAAAC,GAAA,EAED,SAAAA,IAAA,EAAY;MACV,OAAOnD,MAAM,CAACoD,QAAQ,CACpBlD,UAAU,CAACmD,mBAAmB,CAAC,IAAI,CAACV,QAAQ,CAAC,EAC7C3C,MAAM,CAACsD,GACT,CAAC;IACH,CAAC;IAAAC,GAAA,EAED,SAAAA,IAAUP,KAAK,EAAE;MACf9C,UAAU,CAACsD,mBAAmB,CAC5B,IAAI,CAACb,QAAQ,EACb3C,MAAM,CAACoD,QAAQ,CAACJ,KAAK,EAAE,IAAI,CAACA,KAAK,CACnC,CAAC;IACH;EAAC;IAAAE,GAAA;IAAAC,GAAA,EAED,SAAAA,IAAA,EAAmB;MACjB,OAAOjD,UAAU,CAACuD,6BAA6B,CAAC,IAAI,CAACd,QAAQ,CAAC;IAChE,CAAC;IAAAY,GAAA,EAED,SAAAA,IAAiBG,IAAI,EAAE;MACrBxD,UAAU,CAACyD,6BAA6B,CAAC,IAAI,CAAChB,QAAQ,EAAEe,IAAI,KAAK,IAAI,CAAC;IACxE;EAAC;IAAAR,GAAA;IAAAC,GAAA,EAED,SAAAA,IAAA,EAA2B;MACzB,OAAO,IAAI,CAACN,kBAAkB;IAChC,CAAC;IAAAU,GAAA,EAED,SAAAA,IAAyBK,MAAM,EAAE;MAC/B,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;QAC9B,MAAM,IAAIC,SAAS,CAAC,kBAAkB,CAAC;MACzC;MACA,IAAID,MAAM,GAAG,CAAC,EAAE;QACd,MAAM,IAAIE,UAAU,CAAC,cAAc,CAAC;MACtC;MACA,IAAI,CAACjB,kBAAkB,GAAGe,MAAM;IAClC;EAAC;IAAAV,GAAA;IAAAa,KAAA,EAED,SAAAC,IAAIhB,KAAK,EAAW;MAClB,IAAMiB,QAAQ,GAAGjE,MAAM,CAACoD,QAAQ,CAACJ,KAAK,CAAC;MAAC,SAAAkB,IAAA,GAAAxD,SAAA,CAAAC,MAAA,EAD5BwD,IAAI,OAAAC,KAAA,CAAAF,IAAA,OAAAA,IAAA,WAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;QAAJF,IAAI,CAAAE,IAAA,QAAA3D,SAAA,CAAA2D,IAAA;MAAA;MAEhB,IAAI,CAACJ,QAAQ,EAAE;QACb,IAAI9D,aAAa,CAACmE,eAAe,CAACtB,KAAK,CAAC,IAAImB,IAAI,CAACxD,MAAM,GAAG,CAAC,EAAE;UAC3D;UACA,IAAI,CAACqD,GAAG,CACNhE,MAAM,CAACuE,IAAI,EACX,wEAAwE,EACxEvB,KACF,CAAC;UACD,IAAI,CAACgB,GAAG,CAAAQ,KAAA,CAAR,IAAI,GAAKxE,MAAM,CAACyE,IAAI,MAAA1B,MAAA,CAAMC,KAAK,QAAAD,MAAA,CAAQoB,IAAI,EAAC;QAC9C,CAAC,MAAM;UACL;UACA,IAAI,CAACH,GAAG,CAAAQ,KAAA,CAAR,IAAI,GAAKxE,MAAM,CAACyE,IAAI,EAAEzB,KAAK,EAAAD,MAAA,CAAKoB,IAAI,EAAC;QACvC;MACF,CAAC,MAAM,IAAI,IAAI,CAACO,cAAc,CAACT,QAAQ,CAAC,EAAE;QACxC,IAAI,CAACU,IAAI,CAACV,QAAQ,EAAEE,IAAI,CAAC;MAC3B;IACF;EAAC;IAAAjB,GAAA;IAAAa,KAAA,EAED,SAAAW,eAAeE,UAAU,EAAE;MACzB,OAAO,IAAI,CAAC5B,KAAK,CAAC6B,mBAAmB,CAACD,UAAU,CAAC;IACnD;EAAC;IAAA1B,GAAA;IAAAa,KAAA,EAED,SAAAY,KAAK3B,KAAK,EAAExC,IAAI,EAAE;MAChBX,KAAK,sBAAAkD,MAAA,CAAsBC,KAAK,mBAAgB,CAAC;MACjD,IAAMX,KAAK,GAAG7B,IAAI,CAACsE,IAAI,CAAC,UAACC,IAAI;QAAA,OAAKA,IAAI,YAAYrC,KAAK;MAAA,EAAC;MACxD,IAAIT,SAAS;MACb,IAAI,IAAI,CAAC+C,YAAY,EAAE;QACrB,IAAI;UACF,IAAI3C,KAAK,EAAE;YACTJ,SAAS,GAAG,IAAI,CAACa,cAAc,CAC7BT,KAAK,EACL,IAAI,CAACQ,kBAAkB,GAAGxC,iBAC5B,CAAC;UACH;QACF,CAAC,CAAC,OAAO4E,IAAI,EAAE;UACb;QAAA;QAEFhD,SAAS,GACPA,SAAS,IACT,IAAI,CAACa,cAAc,CACjB,IAAIJ,KAAK,CAAC,CAAC,EACX,IAAI,CAACG,kBAAkB,GACrBvC,yBAAyB,GACzBD,iBACJ,CAAC;MACL;MACA,IAAM6E,YAAY,GAAG,IAAInF,YAAY,CACnC,IAAI,CAAC4C,QAAQ,EACbK,KAAK,EACLxC,IAAI,EACJ,IAAI,CAACoC,OAAO,EACZX,SAAS,EACTI,KACF,CAAC;MACDpC,UAAU,CAACkF,IAAI,CAACD,YAAY,CAAC;IAC/B;EAAC;IAAAhC,GAAA;IAAAa,KAAA,EAED,SAAAqB,WAAWlC,GAAG,EAAEa,KAAK,EAAE;MACrB,IAAI,CAACnB,OAAO,CAACM,GAAG,CAAC,GAAGa,KAAK;IAC3B;EAAC;IAAAb,GAAA;IAAAa,KAAA,EAED,SAAAsB,cAAcnC,GAAG,EAAE;MACjB,OAAO,IAAI,CAACN,OAAO,CAACM,GAAG,CAAC;IAC1B;EAAC;IAAAA,GAAA;IAAAa,KAAA,EAED,SAAAuB,aAAA,EAAe;MACb,IAAI,CAAC1C,OAAO,GAAG,CAAC,CAAC;IACnB;EAAC;IAAAM,GAAA;IAAAa,KAAA,EAED,SAAAwB,0BAA0BC,aAAa,EAAE;MACvC,IAAI,OAAOA,aAAa,KAAK,UAAU,EAAE;QACvC,IAAI,CAAC1C,cAAc,GAAG0C,aAAa;MACrC,CAAC,MAAM,IAAI,OAAOA,aAAa,KAAK,WAAW,EAAE;QAC/C,IAAI,CAAC1C,cAAc,GAAGvC,qBAAqB;MAC7C,CAAC,MAAM;QACL,MAAM,IAAIsD,SAAS,CAAC,kDAAkD,CAAC;MACzE;IACF;EAAC;EAAA,OAAAtB,MAAA;AAAA;AAGH,SAASkD,eAAeA,CAACC,MAAM,EAAE;EAC/B,IAAM1C,KAAK,GAAGhD,MAAM,CAACoD,QAAQ,CAACsC,MAAM,CAAC;EAErC,IAAMC,aAAa,GAAG3C,KAAK,CAAC4C,QAAQ,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;EACpD,IAAMC,WAAW,GAAGH,aAAa,CAACpE,OAAO,CAAC,WAAW,EAAE,UAACwE,CAAC;IAAA,OACvDA,CAAC,CAAC,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;EAAA,CACpB,CAAC;EACD,IAAMC,aAAa,GAAGH,WAAW,CAAC,CAAC,CAAC,CAACE,WAAW,CAAC,CAAC,GAAGF,WAAW,CAAC9E,KAAK,CAAC,CAAC,CAAC;EAEzEuB,MAAM,CAAC2D,SAAS,MAAAnD,MAAA,CAAMkD,aAAa,aAAU,GAAG,YAAY;IAC1D,OAAO,IAAI,CAACvB,cAAc,CAAC1B,KAAK,CAAC;EACnC,CAAC;EAEDT,MAAM,CAAC2D,SAAS,CAACJ,WAAW,CAAC,GAAG,YAAmB;IAAA,SAAAK,KAAA,GAAAzF,SAAA,CAAAC,MAAA,EAANwD,IAAI,OAAAC,KAAA,CAAA+B,KAAA,GAAAC,KAAA,MAAAA,KAAA,GAAAD,KAAA,EAAAC,KAAA;MAAJjC,IAAI,CAAAiC,KAAA,IAAA1F,SAAA,CAAA0F,KAAA;IAAA;IAC/C,IAAI,CAACpC,GAAG,CAAAQ,KAAA,CAAR,IAAI,GAAKxB,KAAK,EAAAD,MAAA,CAAKoB,IAAI,EAAC;EAC1B,CAAC;AACH;AAEAnE,MAAM,CAACA,MAAM,CAACqG,OAAO,CAACZ,eAAe,CAAC;AAEtCtF,aAAa,CAACmG,WAAW,CAAC,YAAM;EAC9BtG,MAAM,CAACA,MAAM,CAACqG,OAAO,CAACZ,eAAe,CAAC;AACxC,CAAC,CAAC;AAEFc,MAAM,CAACC,OAAO,GAAGjE,MAAM"},"metadata":{},"sourceType":"script"}