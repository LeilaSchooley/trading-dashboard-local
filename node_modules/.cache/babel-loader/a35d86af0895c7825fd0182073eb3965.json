{"ast":null,"code":"// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport { HandshakeProtocol } from \"./HandshakeProtocol\";\nimport { MessageType } from \"./IHubProtocol\";\nimport { LogLevel } from \"./ILogger\";\nimport { Subject } from \"./Subject\";\nimport { Arg } from \"./Utils\";\nvar DEFAULT_TIMEOUT_IN_MS = 30 * 1000;\nvar DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;\n/** Describes the current state of the {@link HubConnection} to the server. */\nexport var HubConnectionState;\n(function (HubConnectionState) {\n  /** The hub connection is disconnected. */\n  HubConnectionState[\"Disconnected\"] = \"Disconnected\";\n  /** The hub connection is connecting. */\n  HubConnectionState[\"Connecting\"] = \"Connecting\";\n  /** The hub connection is connected. */\n  HubConnectionState[\"Connected\"] = \"Connected\";\n  /** The hub connection is disconnecting. */\n  HubConnectionState[\"Disconnecting\"] = \"Disconnecting\";\n  /** The hub connection is reconnecting. */\n  HubConnectionState[\"Reconnecting\"] = \"Reconnecting\";\n})(HubConnectionState || (HubConnectionState = {}));\n/** Represents a connection to a SignalR Hub. */\nvar HubConnection = /** @class */function () {\n  function HubConnection(connection, logger, protocol, reconnectPolicy) {\n    var _this = this;\n    this.nextKeepAlive = 0;\n    Arg.isRequired(connection, \"connection\");\n    Arg.isRequired(logger, \"logger\");\n    Arg.isRequired(protocol, \"protocol\");\n    this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\n    this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\n    this.logger = logger;\n    this.protocol = protocol;\n    this.connection = connection;\n    this.reconnectPolicy = reconnectPolicy;\n    this.handshakeProtocol = new HandshakeProtocol();\n    this.connection.onreceive = function (data) {\n      return _this.processIncomingData(data);\n    };\n    this.connection.onclose = function (error) {\n      return _this.connectionClosed(error);\n    };\n    this.callbacks = {};\n    this.methods = {};\n    this.closedCallbacks = [];\n    this.reconnectingCallbacks = [];\n    this.reconnectedCallbacks = [];\n    this.invocationId = 0;\n    this.receivedHandshakeResponse = false;\n    this.connectionState = HubConnectionState.Disconnected;\n    this.connectionStarted = false;\n    this.cachedPingMessage = this.protocol.writeMessage({\n      type: MessageType.Ping\n    });\n  }\n  /** @internal */\n  // Using a public static factory method means we can have a private constructor and an _internal_\n  // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\n  // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\n  // public parameter-less constructor.\n  HubConnection.create = function (connection, logger, protocol, reconnectPolicy) {\n    return new HubConnection(connection, logger, protocol, reconnectPolicy);\n  };\n  Object.defineProperty(HubConnection.prototype, \"state\", {\n    /** Indicates the state of the {@link HubConnection} to the server. */\n    get: function () {\n      return this.connectionState;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HubConnection.prototype, \"connectionId\", {\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\n    get: function () {\n      return this.connection ? this.connection.connectionId || null : null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(HubConnection.prototype, \"baseUrl\", {\n    /** Indicates the url of the {@link HubConnection} to the server. */\n    get: function () {\n      return this.connection.baseUrl || \"\";\n    },\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\n    set: function (url) {\n      if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {\n        throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\n      }\n      if (!url) {\n        throw new Error(\"The HubConnection url must be a valid url.\");\n      }\n      this.connection.baseUrl = url;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** Starts the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n   */\n  HubConnection.prototype.start = function () {\n    this.startPromise = this.startWithStateTransitions();\n    return this.startPromise;\n  };\n  HubConnection.prototype.startWithStateTransitions = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.connectionState !== HubConnectionState.Disconnected) {\n              return [2 /*return*/, Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"))];\n            }\n            this.connectionState = HubConnectionState.Connecting;\n            this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n            return [4 /*yield*/, this.startInternal()];\n          case 2:\n            _a.sent();\n            this.connectionState = HubConnectionState.Connected;\n            this.connectionStarted = true;\n            this.logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\n            return [3 /*break*/, 4];\n          case 3:\n            e_1 = _a.sent();\n            this.connectionState = HubConnectionState.Disconnected;\n            this.logger.log(LogLevel.Debug, \"HubConnection failed to start successfully because of error '\" + e_1 + \"'.\");\n            return [2 /*return*/, Promise.reject(e_1)];\n          case 4:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  HubConnection.prototype.startInternal = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var handshakePromise, handshakeRequest, e_2;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.stopDuringStartError = undefined;\n            this.receivedHandshakeResponse = false;\n            handshakePromise = new Promise(function (resolve, reject) {\n              _this.handshakeResolver = resolve;\n              _this.handshakeRejecter = reject;\n            });\n            return [4 /*yield*/, this.connection.start(this.protocol.transferFormat)];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 5,, 7]);\n            handshakeRequest = {\n              protocol: this.protocol.name,\n              version: this.protocol.version\n            };\n            this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\n            return [4 /*yield*/, this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];\n          case 3:\n            _a.sent();\n            this.logger.log(LogLevel.Information, \"Using HubProtocol '\" + this.protocol.name + \"'.\");\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\n            this.cleanupTimeout();\n            this.resetTimeoutPeriod();\n            this.resetKeepAliveInterval();\n            return [4 /*yield*/, handshakePromise];\n          case 4:\n            _a.sent();\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\n            // and the connection was closed.\n            if (this.stopDuringStartError) {\n              // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\n              // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\n              // will cause the calling continuation to get scheduled to run later.\n              throw this.stopDuringStartError;\n            }\n            return [3 /*break*/, 7];\n          case 5:\n            e_2 = _a.sent();\n            this.logger.log(LogLevel.Debug, \"Hub handshake failed with error '\" + e_2 + \"' during start(). Stopping HubConnection.\");\n            this.cleanupTimeout();\n            this.cleanupPingTimer();\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n            return [4 /*yield*/, this.connection.stop(e_2)];\n          case 6:\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\n            _a.sent();\n            throw e_2;\n          case 7:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n  /** Stops the connection.\r\n   *\r\n   * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n   */\n  HubConnection.prototype.stop = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var startPromise, e_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            startPromise = this.startPromise;\n            this.stopPromise = this.stopInternal();\n            return [4 /*yield*/, this.stopPromise];\n          case 1:\n            _a.sent();\n            _a.label = 2;\n          case 2:\n            _a.trys.push([2, 4,, 5]);\n            // Awaiting undefined continues immediately\n            return [4 /*yield*/, startPromise];\n          case 3:\n            // Awaiting undefined continues immediately\n            _a.sent();\n            return [3 /*break*/, 5];\n          case 4:\n            e_3 = _a.sent();\n            return [3 /*break*/, 5];\n          case 5:\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  HubConnection.prototype.stopInternal = function (error) {\n    if (this.connectionState === HubConnectionState.Disconnected) {\n      this.logger.log(LogLevel.Debug, \"Call to HubConnection.stop(\" + error + \") ignored because it is already in the disconnected state.\");\n      return Promise.resolve();\n    }\n    if (this.connectionState === HubConnectionState.Disconnecting) {\n      this.logger.log(LogLevel.Debug, \"Call to HttpConnection.stop(\" + error + \") ignored because the connection is already in the disconnecting state.\");\n      return this.stopPromise;\n    }\n    this.connectionState = HubConnectionState.Disconnecting;\n    this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\n    if (this.reconnectDelayHandle) {\n      // We're in a reconnect delay which means the underlying connection is currently already stopped.\n      // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\n      // fire the onclose callbacks.\n      this.logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\n      clearTimeout(this.reconnectDelayHandle);\n      this.reconnectDelayHandle = undefined;\n      this.completeClose();\n      return Promise.resolve();\n    }\n    this.cleanupTimeout();\n    this.cleanupPingTimer();\n    this.stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\");\n    // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\n    // or the onclose callback is invoked. The onclose callback will transition the HubConnection\n    // to the disconnected state if need be before HttpConnection.stop() completes.\n    return this.connection.stop(error);\n  };\n  /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n   *\r\n   * @typeparam T The type of the items returned by the server.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n   */\n  HubConnection.prototype.stream = function (methodName) {\n    var _this = this;\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n    var _a = this.replaceStreamingParams(args),\n      streams = _a[0],\n      streamIds = _a[1];\n    var invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);\n    var promiseQueue;\n    var subject = new Subject();\n    subject.cancelCallback = function () {\n      var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);\n      delete _this.callbacks[invocationDescriptor.invocationId];\n      return promiseQueue.then(function () {\n        return _this.sendWithProtocol(cancelInvocation);\n      });\n    };\n    this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n      if (error) {\n        subject.error(error);\n        return;\n      } else if (invocationEvent) {\n        // invocationEvent will not be null when an error is not passed to the callback\n        if (invocationEvent.type === MessageType.Completion) {\n          if (invocationEvent.error) {\n            subject.error(new Error(invocationEvent.error));\n          } else {\n            subject.complete();\n          }\n        } else {\n          subject.next(invocationEvent.item);\n        }\n      }\n    };\n    promiseQueue = this.sendWithProtocol(invocationDescriptor).catch(function (e) {\n      subject.error(e);\n      delete _this.callbacks[invocationDescriptor.invocationId];\n    });\n    this.launchStreams(streams, promiseQueue);\n    return subject;\n  };\n  HubConnection.prototype.sendMessage = function (message) {\n    this.resetKeepAliveInterval();\n    return this.connection.send(message);\n  };\n  /**\r\n   * Sends a js object to the server.\r\n   * @param message The js object to serialize and send.\r\n   */\n  HubConnection.prototype.sendWithProtocol = function (message) {\n    return this.sendMessage(this.protocol.writeMessage(message));\n  };\n  /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n   *\r\n   * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n   * be processing the invocation.\r\n   *\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n   */\n  HubConnection.prototype.send = function (methodName) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n    var _a = this.replaceStreamingParams(args),\n      streams = _a[0],\n      streamIds = _a[1];\n    var sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));\n    this.launchStreams(streams, sendPromise);\n    return sendPromise;\n  };\n  /** Invokes a hub method on the server using the specified name and arguments.\r\n   *\r\n   * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n   * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n   * resolving the Promise.\r\n   *\r\n   * @typeparam T The expected return type.\r\n   * @param {string} methodName The name of the server method to invoke.\r\n   * @param {any[]} args The arguments used to invoke the server method.\r\n   * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n   */\n  HubConnection.prototype.invoke = function (methodName) {\n    var _this = this;\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n    var _a = this.replaceStreamingParams(args),\n      streams = _a[0],\n      streamIds = _a[1];\n    var invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);\n    var p = new Promise(function (resolve, reject) {\n      // invocationId will always have a value for a non-blocking invocation\n      _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {\n        if (error) {\n          reject(error);\n          return;\n        } else if (invocationEvent) {\n          // invocationEvent will not be null when an error is not passed to the callback\n          if (invocationEvent.type === MessageType.Completion) {\n            if (invocationEvent.error) {\n              reject(new Error(invocationEvent.error));\n            } else {\n              resolve(invocationEvent.result);\n            }\n          } else {\n            reject(new Error(\"Unexpected message type: \" + invocationEvent.type));\n          }\n        }\n      };\n      var promiseQueue = _this.sendWithProtocol(invocationDescriptor).catch(function (e) {\n        reject(e);\n        // invocationId will always have a value for a non-blocking invocation\n        delete _this.callbacks[invocationDescriptor.invocationId];\n      });\n      _this.launchStreams(streams, promiseQueue);\n    });\n    return p;\n  };\n  /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n   *\r\n   * @param {string} methodName The name of the hub method to define.\r\n   * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n   */\n  HubConnection.prototype.on = function (methodName, newMethod) {\n    if (!methodName || !newMethod) {\n      return;\n    }\n    methodName = methodName.toLowerCase();\n    if (!this.methods[methodName]) {\n      this.methods[methodName] = [];\n    }\n    // Preventing adding the same handler multiple times.\n    if (this.methods[methodName].indexOf(newMethod) !== -1) {\n      return;\n    }\n    this.methods[methodName].push(newMethod);\n  };\n  HubConnection.prototype.off = function (methodName, method) {\n    if (!methodName) {\n      return;\n    }\n    methodName = methodName.toLowerCase();\n    var handlers = this.methods[methodName];\n    if (!handlers) {\n      return;\n    }\n    if (method) {\n      var removeIdx = handlers.indexOf(method);\n      if (removeIdx !== -1) {\n        handlers.splice(removeIdx, 1);\n        if (handlers.length === 0) {\n          delete this.methods[methodName];\n        }\n      }\n    } else {\n      delete this.methods[methodName];\n    }\n  };\n  /** Registers a handler that will be invoked when the connection is closed.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n   */\n  HubConnection.prototype.onclose = function (callback) {\n    if (callback) {\n      this.closedCallbacks.push(callback);\n    }\n  };\n  /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n   */\n  HubConnection.prototype.onreconnecting = function (callback) {\n    if (callback) {\n      this.reconnectingCallbacks.push(callback);\n    }\n  };\n  /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n   *\r\n   * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n   */\n  HubConnection.prototype.onreconnected = function (callback) {\n    if (callback) {\n      this.reconnectedCallbacks.push(callback);\n    }\n  };\n  HubConnection.prototype.processIncomingData = function (data) {\n    this.cleanupTimeout();\n    if (!this.receivedHandshakeResponse) {\n      data = this.processHandshakeResponse(data);\n      this.receivedHandshakeResponse = true;\n    }\n    // Data may have all been read when processing handshake response\n    if (data) {\n      // Parse the messages\n      var messages = this.protocol.parseMessages(data, this.logger);\n      for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {\n        var message = messages_1[_i];\n        switch (message.type) {\n          case MessageType.Invocation:\n            this.invokeClientMethod(message);\n            break;\n          case MessageType.StreamItem:\n          case MessageType.Completion:\n            var callback = this.callbacks[message.invocationId];\n            if (callback) {\n              if (message.type === MessageType.Completion) {\n                delete this.callbacks[message.invocationId];\n              }\n              callback(message);\n            }\n            break;\n          case MessageType.Ping:\n            // Don't care about pings\n            break;\n          case MessageType.Close:\n            this.logger.log(LogLevel.Information, \"Close message received from server.\");\n            var error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\n            if (message.allowReconnect === true) {\n              // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\n              // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\n              // tslint:disable-next-line:no-floating-promises\n              this.connection.stop(error);\n            } else {\n              // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\n              this.stopPromise = this.stopInternal(error);\n            }\n            break;\n          default:\n            this.logger.log(LogLevel.Warning, \"Invalid message type: \" + message.type + \".\");\n            break;\n        }\n      }\n    }\n    this.resetTimeoutPeriod();\n  };\n  HubConnection.prototype.processHandshakeResponse = function (data) {\n    var _a;\n    var responseMessage;\n    var remainingData;\n    try {\n      _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];\n    } catch (e) {\n      var message = \"Error parsing handshake response: \" + e;\n      this.logger.log(LogLevel.Error, message);\n      var error = new Error(message);\n      this.handshakeRejecter(error);\n      throw error;\n    }\n    if (responseMessage.error) {\n      var message = \"Server returned handshake error: \" + responseMessage.error;\n      this.logger.log(LogLevel.Error, message);\n      var error = new Error(message);\n      this.handshakeRejecter(error);\n      throw error;\n    } else {\n      this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\n    }\n    this.handshakeResolver();\n    return remainingData;\n  };\n  HubConnection.prototype.resetKeepAliveInterval = function () {\n    if (this.connection.features.inherentKeepAlive) {\n      return;\n    }\n    // Set the time we want the next keep alive to be sent\n    // Timer will be setup on next message receive\n    this.nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\n    this.cleanupPingTimer();\n  };\n  HubConnection.prototype.resetTimeoutPeriod = function () {\n    var _this = this;\n    if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\n      // Set the timeout timer\n      this.timeoutHandle = setTimeout(function () {\n        return _this.serverTimeout();\n      }, this.serverTimeoutInMilliseconds);\n      // Set keepAlive timer if there isn't one\n      if (this.pingServerHandle === undefined) {\n        var nextPing = this.nextKeepAlive - new Date().getTime();\n        if (nextPing < 0) {\n          nextPing = 0;\n        }\n        // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\n        this.pingServerHandle = setTimeout(function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var _a;\n            return __generator(this, function (_b) {\n              switch (_b.label) {\n                case 0:\n                  if (!(this.connectionState === HubConnectionState.Connected)) return [3 /*break*/, 4];\n                  _b.label = 1;\n                case 1:\n                  _b.trys.push([1, 3,, 4]);\n                  return [4 /*yield*/, this.sendMessage(this.cachedPingMessage)];\n                case 2:\n                  _b.sent();\n                  return [3 /*break*/, 4];\n                case 3:\n                  _a = _b.sent();\n                  // We don't care about the error. It should be seen elsewhere in the client.\n                  // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\n                  this.cleanupPingTimer();\n                  return [3 /*break*/, 4];\n                case 4:\n                  return [2 /*return*/];\n              }\n            });\n          });\n        }, nextPing);\n      }\n    }\n  };\n  HubConnection.prototype.serverTimeout = function () {\n    // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\n    // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\n    // tslint:disable-next-line:no-floating-promises\n    this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\n  };\n  HubConnection.prototype.invokeClientMethod = function (invocationMessage) {\n    var _this = this;\n    var methods = this.methods[invocationMessage.target.toLowerCase()];\n    if (methods) {\n      try {\n        methods.forEach(function (m) {\n          return m.apply(_this, invocationMessage.arguments);\n        });\n      } catch (e) {\n        this.logger.log(LogLevel.Error, \"A callback for the method \" + invocationMessage.target.toLowerCase() + \" threw error '\" + e + \"'.\");\n      }\n      if (invocationMessage.invocationId) {\n        // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\n        var message = \"Server requested a response, which is not supported in this version of the client.\";\n        this.logger.log(LogLevel.Error, message);\n        // We don't want to wait on the stop itself.\n        this.stopPromise = this.stopInternal(new Error(message));\n      }\n    } else {\n      this.logger.log(LogLevel.Warning, \"No client method with the name '\" + invocationMessage.target + \"' found.\");\n    }\n  };\n  HubConnection.prototype.connectionClosed = function (error) {\n    this.logger.log(LogLevel.Debug, \"HubConnection.connectionClosed(\" + error + \") called while in state \" + this.connectionState + \".\");\n    // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\n    this.stopDuringStartError = this.stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\");\n    // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\n    // If it has already completed, this should just noop.\n    if (this.handshakeResolver) {\n      this.handshakeResolver();\n    }\n    this.cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\n    this.cleanupTimeout();\n    this.cleanupPingTimer();\n    if (this.connectionState === HubConnectionState.Disconnecting) {\n      this.completeClose(error);\n    } else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {\n      // tslint:disable-next-line:no-floating-promises\n      this.reconnect(error);\n    } else if (this.connectionState === HubConnectionState.Connected) {\n      this.completeClose(error);\n    }\n    // If none of the above if conditions were true were called the HubConnection must be in either:\n    // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\n    // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\n    //    and potentially continue the reconnect() loop.\n    // 3. The Disconnected state in which case we're already done.\n  };\n\n  HubConnection.prototype.completeClose = function (error) {\n    var _this = this;\n    if (this.connectionStarted) {\n      this.connectionState = HubConnectionState.Disconnected;\n      this.connectionStarted = false;\n      try {\n        this.closedCallbacks.forEach(function (c) {\n          return c.apply(_this, [error]);\n        });\n      } catch (e) {\n        this.logger.log(LogLevel.Error, \"An onclose callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\n      }\n    }\n  };\n  HubConnection.prototype.reconnect = function (error) {\n    return __awaiter(this, void 0, void 0, function () {\n      var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay, e_4;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            reconnectStartTime = Date.now();\n            previousReconnectAttempts = 0;\n            retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\n            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\n            if (nextRetryDelay === null) {\n              this.logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\n              this.completeClose(error);\n              return [2 /*return*/];\n            }\n\n            this.connectionState = HubConnectionState.Reconnecting;\n            if (error) {\n              this.logger.log(LogLevel.Information, \"Connection reconnecting because of error '\" + error + \"'.\");\n            } else {\n              this.logger.log(LogLevel.Information, \"Connection reconnecting.\");\n            }\n            if (this.onreconnecting) {\n              try {\n                this.reconnectingCallbacks.forEach(function (c) {\n                  return c.apply(_this, [error]);\n                });\n              } catch (e) {\n                this.logger.log(LogLevel.Error, \"An onreconnecting callback called with error '\" + error + \"' threw error '\" + e + \"'.\");\n              }\n              // Exit early if an onreconnecting callback called connection.stop().\n              if (this.connectionState !== HubConnectionState.Reconnecting) {\n                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\n                return [2 /*return*/];\n              }\n            }\n\n            _a.label = 1;\n          case 1:\n            if (!(nextRetryDelay !== null)) return [3 /*break*/, 7];\n            this.logger.log(LogLevel.Information, \"Reconnect attempt number \" + previousReconnectAttempts + \" will start in \" + nextRetryDelay + \" ms.\");\n            return [4 /*yield*/, new Promise(function (resolve) {\n              _this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);\n            })];\n          case 2:\n            _a.sent();\n            this.reconnectDelayHandle = undefined;\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\n              this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\n              return [2 /*return*/];\n            }\n\n            _a.label = 3;\n          case 3:\n            _a.trys.push([3, 5,, 6]);\n            return [4 /*yield*/, this.startInternal()];\n          case 4:\n            _a.sent();\n            this.connectionState = HubConnectionState.Connected;\n            this.logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\n            if (this.onreconnected) {\n              try {\n                this.reconnectedCallbacks.forEach(function (c) {\n                  return c.apply(_this, [_this.connection.connectionId]);\n                });\n              } catch (e) {\n                this.logger.log(LogLevel.Error, \"An onreconnected callback called with connectionId '\" + this.connection.connectionId + \"; threw error '\" + e + \"'.\");\n              }\n            }\n            return [2 /*return*/];\n          case 5:\n            e_4 = _a.sent();\n            this.logger.log(LogLevel.Information, \"Reconnect attempt failed because of error '\" + e_4 + \"'.\");\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\n              this.logger.log(LogLevel.Debug, \"Connection moved to the '\" + this.connectionState + \"' from the reconnecting state during reconnect attempt. Done reconnecting.\");\n              // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\n              if (this.connectionState === HubConnectionState.Disconnecting) {\n                this.completeClose();\n              }\n              return [2 /*return*/];\n            }\n\n            retryError = e_4 instanceof Error ? e_4 : new Error(e_4.toString());\n            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\n            return [3 /*break*/, 6];\n          case 6:\n            return [3 /*break*/, 1];\n          case 7:\n            this.logger.log(LogLevel.Information, \"Reconnect retries have been exhausted after \" + (Date.now() - reconnectStartTime) + \" ms and \" + previousReconnectAttempts + \" failed attempts. Connection disconnecting.\");\n            this.completeClose();\n            return [2 /*return*/];\n        }\n      });\n    });\n  };\n\n  HubConnection.prototype.getNextRetryDelay = function (previousRetryCount, elapsedMilliseconds, retryReason) {\n    try {\n      return this.reconnectPolicy.nextRetryDelayInMilliseconds({\n        elapsedMilliseconds: elapsedMilliseconds,\n        previousRetryCount: previousRetryCount,\n        retryReason: retryReason\n      });\n    } catch (e) {\n      this.logger.log(LogLevel.Error, \"IRetryPolicy.nextRetryDelayInMilliseconds(\" + previousRetryCount + \", \" + elapsedMilliseconds + \") threw error '\" + e + \"'.\");\n      return null;\n    }\n  };\n  HubConnection.prototype.cancelCallbacksWithError = function (error) {\n    var callbacks = this.callbacks;\n    this.callbacks = {};\n    Object.keys(callbacks).forEach(function (key) {\n      var callback = callbacks[key];\n      callback(null, error);\n    });\n  };\n  HubConnection.prototype.cleanupPingTimer = function () {\n    if (this.pingServerHandle) {\n      clearTimeout(this.pingServerHandle);\n      this.pingServerHandle = undefined;\n    }\n  };\n  HubConnection.prototype.cleanupTimeout = function () {\n    if (this.timeoutHandle) {\n      clearTimeout(this.timeoutHandle);\n    }\n  };\n  HubConnection.prototype.createInvocation = function (methodName, args, nonblocking, streamIds) {\n    if (nonblocking) {\n      if (streamIds.length !== 0) {\n        return {\n          arguments: args,\n          streamIds: streamIds,\n          target: methodName,\n          type: MessageType.Invocation\n        };\n      } else {\n        return {\n          arguments: args,\n          target: methodName,\n          type: MessageType.Invocation\n        };\n      }\n    } else {\n      var invocationId = this.invocationId;\n      this.invocationId++;\n      if (streamIds.length !== 0) {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          streamIds: streamIds,\n          target: methodName,\n          type: MessageType.Invocation\n        };\n      } else {\n        return {\n          arguments: args,\n          invocationId: invocationId.toString(),\n          target: methodName,\n          type: MessageType.Invocation\n        };\n      }\n    }\n  };\n  HubConnection.prototype.launchStreams = function (streams, promiseQueue) {\n    var _this = this;\n    if (streams.length === 0) {\n      return;\n    }\n    // Synchronize stream data so they arrive in-order on the server\n    if (!promiseQueue) {\n      promiseQueue = Promise.resolve();\n    }\n    var _loop_1 = function (streamId) {\n      streams[streamId].subscribe({\n        complete: function () {\n          promiseQueue = promiseQueue.then(function () {\n            return _this.sendWithProtocol(_this.createCompletionMessage(streamId));\n          });\n        },\n        error: function (err) {\n          var message;\n          if (err instanceof Error) {\n            message = err.message;\n          } else if (err && err.toString) {\n            message = err.toString();\n          } else {\n            message = \"Unknown error\";\n          }\n          promiseQueue = promiseQueue.then(function () {\n            return _this.sendWithProtocol(_this.createCompletionMessage(streamId, message));\n          });\n        },\n        next: function (item) {\n          promiseQueue = promiseQueue.then(function () {\n            return _this.sendWithProtocol(_this.createStreamItemMessage(streamId, item));\n          });\n        }\n      });\n    };\n    // We want to iterate over the keys, since the keys are the stream ids\n    // tslint:disable-next-line:forin\n    for (var streamId in streams) {\n      _loop_1(streamId);\n    }\n  };\n  HubConnection.prototype.replaceStreamingParams = function (args) {\n    var streams = [];\n    var streamIds = [];\n    for (var i = 0; i < args.length; i++) {\n      var argument = args[i];\n      if (this.isObservable(argument)) {\n        var streamId = this.invocationId;\n        this.invocationId++;\n        // Store the stream for later use\n        streams[streamId] = argument;\n        streamIds.push(streamId.toString());\n        // remove stream from args\n        args.splice(i, 1);\n      }\n    }\n    return [streams, streamIds];\n  };\n  HubConnection.prototype.isObservable = function (arg) {\n    // This allows other stream implementations to just work (like rxjs)\n    return arg && arg.subscribe && typeof arg.subscribe === \"function\";\n  };\n  HubConnection.prototype.createStreamInvocation = function (methodName, args, streamIds) {\n    var invocationId = this.invocationId;\n    this.invocationId++;\n    if (streamIds.length !== 0) {\n      return {\n        arguments: args,\n        invocationId: invocationId.toString(),\n        streamIds: streamIds,\n        target: methodName,\n        type: MessageType.StreamInvocation\n      };\n    } else {\n      return {\n        arguments: args,\n        invocationId: invocationId.toString(),\n        target: methodName,\n        type: MessageType.StreamInvocation\n      };\n    }\n  };\n  HubConnection.prototype.createCancelInvocation = function (id) {\n    return {\n      invocationId: id,\n      type: MessageType.CancelInvocation\n    };\n  };\n  HubConnection.prototype.createStreamItemMessage = function (id, item) {\n    return {\n      invocationId: id,\n      item: item,\n      type: MessageType.StreamItem\n    };\n  };\n  HubConnection.prototype.createCompletionMessage = function (id, error, result) {\n    if (error) {\n      return {\n        error: error,\n        invocationId: id,\n        type: MessageType.Completion\n      };\n    }\n    return {\n      invocationId: id,\n      result: result,\n      type: MessageType.Completion\n    };\n  };\n  return HubConnection;\n}();\nexport { HubConnection };","map":{"version":3,"names":["HandshakeProtocol","MessageType","LogLevel","Subject","Arg","DEFAULT_TIMEOUT_IN_MS","DEFAULT_PING_INTERVAL_IN_MS","HubConnectionState","HubConnection","connection","logger","protocol","reconnectPolicy","_this","nextKeepAlive","isRequired","serverTimeoutInMilliseconds","keepAliveIntervalInMilliseconds","handshakeProtocol","onreceive","data","processIncomingData","onclose","error","connectionClosed","callbacks","methods","closedCallbacks","reconnectingCallbacks","reconnectedCallbacks","invocationId","receivedHandshakeResponse","connectionState","Disconnected","connectionStarted","cachedPingMessage","writeMessage","type","Ping","create","Object","defineProperty","prototype","get","connectionId","baseUrl","set","url","Reconnecting","Error","start","startPromise","startWithStateTransitions","Promise","reject","Connecting","log","Debug","startInternal","_a","sent","Connected","e_1","stopDuringStartError","undefined","handshakePromise","resolve","handshakeResolver","handshakeRejecter","transferFormat","handshakeRequest","name","version","sendMessage","writeHandshakeRequest","Information","cleanupTimeout","resetTimeoutPeriod","resetKeepAliveInterval","e_2","cleanupPingTimer","stop","stopPromise","stopInternal","Disconnecting","reconnectDelayHandle","clearTimeout","completeClose","stream","methodName","args","_i","arguments","length","replaceStreamingParams","streams","streamIds","invocationDescriptor","createStreamInvocation","promiseQueue","subject","cancelCallback","cancelInvocation","createCancelInvocation","then","sendWithProtocol","invocationEvent","Completion","complete","next","item","catch","e","launchStreams","message","send","sendPromise","createInvocation","invoke","p","result","on","newMethod","toLowerCase","indexOf","push","off","method","handlers","removeIdx","splice","callback","onreconnecting","onreconnected","processHandshakeResponse","messages","parseMessages","messages_1","Invocation","invokeClientMethod","StreamItem","Close","allowReconnect","Warning","responseMessage","remainingData","parseHandshakeResponse","features","inherentKeepAlive","Date","getTime","timeoutHandle","setTimeout","serverTimeout","pingServerHandle","nextPing","__awaiter","_b","invocationMessage","target","forEach","m","apply","cancelCallbacksWithError","reconnect","c","reconnectStartTime","now","previousReconnectAttempts","retryError","nextRetryDelay","getNextRetryDelay","e_4","toString","previousRetryCount","elapsedMilliseconds","retryReason","nextRetryDelayInMilliseconds","keys","key","nonblocking","streamId","subscribe","createCompletionMessage","err","createStreamItemMessage","i","argument","isObservable","arg","StreamInvocation","id","CancelInvocation"],"sources":["../../src/HubConnection.ts"],"sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\nimport { HandshakeProtocol, HandshakeRequestMessage, HandshakeResponseMessage } from \"./HandshakeProtocol\";\r\nimport { IConnection } from \"./IConnection\";\r\nimport { CancelInvocationMessage, CompletionMessage, IHubProtocol, InvocationMessage, MessageType, StreamInvocationMessage, StreamItemMessage } from \"./IHubProtocol\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { IRetryPolicy } from \"./IRetryPolicy\";\r\nimport { IStreamResult } from \"./Stream\";\r\nimport { Subject } from \"./Subject\";\r\nimport { Arg } from \"./Utils\";\r\n\r\nconst DEFAULT_TIMEOUT_IN_MS: number = 30 * 1000;\r\nconst DEFAULT_PING_INTERVAL_IN_MS: number = 15 * 1000;\r\n\r\n/** Describes the current state of the {@link HubConnection} to the server. */\r\nexport enum HubConnectionState {\r\n    /** The hub connection is disconnected. */\r\n    Disconnected = \"Disconnected\",\r\n    /** The hub connection is connecting. */\r\n    Connecting = \"Connecting\",\r\n    /** The hub connection is connected. */\r\n    Connected = \"Connected\",\r\n    /** The hub connection is disconnecting. */\r\n    Disconnecting = \"Disconnecting\",\r\n    /** The hub connection is reconnecting. */\r\n    Reconnecting = \"Reconnecting\",\r\n}\r\n\r\n/** Represents a connection to a SignalR Hub. */\r\nexport class HubConnection {\r\n    private readonly cachedPingMessage: string | ArrayBuffer;\r\n    private readonly connection: IConnection;\r\n    private readonly logger: ILogger;\r\n    private readonly reconnectPolicy?: IRetryPolicy;\r\n    private protocol: IHubProtocol;\r\n    private handshakeProtocol: HandshakeProtocol;\r\n    private callbacks: { [invocationId: string]: (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => void };\r\n    private methods: { [name: string]: Array<(...args: any[]) => void> };\r\n    private invocationId: number;\r\n\r\n    private closedCallbacks: Array<(error?: Error) => void>;\r\n    private reconnectingCallbacks: Array<(error?: Error) => void>;\r\n    private reconnectedCallbacks: Array<(connectionId?: string) => void>;\r\n\r\n    private receivedHandshakeResponse: boolean;\r\n    private handshakeResolver!: (value?: PromiseLike<{}>) => void;\r\n    private handshakeRejecter!: (reason?: any) => void;\r\n    private stopDuringStartError?: Error;\r\n\r\n    private connectionState: HubConnectionState;\r\n    // connectionStarted is tracked independently from connectionState, so we can check if the\r\n    // connection ever did successfully transition from connecting to connected before disconnecting.\r\n    private connectionStarted: boolean;\r\n    private startPromise?: Promise<void>;\r\n    private stopPromise?: Promise<void>;\r\n    private nextKeepAlive: number = 0;\r\n\r\n    // The type of these a) doesn't matter and b) varies when building in browser and node contexts\r\n    // Since we're building the WebPack bundle directly from the TypeScript, this matters (previously\r\n    // we built the bundle from the compiled JavaScript).\r\n    private reconnectDelayHandle?: any;\r\n    private timeoutHandle?: any;\r\n    private pingServerHandle?: any;\r\n\r\n    /** The server timeout in milliseconds.\r\n     *\r\n     * If this timeout elapses without receiving any messages from the server, the connection will be terminated with an error.\r\n     * The default timeout value is 30,000 milliseconds (30 seconds).\r\n     */\r\n    public serverTimeoutInMilliseconds: number;\r\n\r\n    /** Default interval at which to ping the server.\r\n     *\r\n     * The default value is 15,000 milliseconds (15 seconds).\r\n     * Allows the server to detect hard disconnects (like when a client unplugs their computer).\r\n     * The ping will happen at most as often as the server pings.\r\n     * If the server pings every 5 seconds, a value lower than 5 will ping every 5 seconds.\r\n     */\r\n    public keepAliveIntervalInMilliseconds: number;\r\n\r\n    /** @internal */\r\n    // Using a public static factory method means we can have a private constructor and an _internal_\r\n    // create method that can be used by HubConnectionBuilder. An \"internal\" constructor would just\r\n    // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a\r\n    // public parameter-less constructor.\r\n    public static create(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy): HubConnection {\r\n        return new HubConnection(connection, logger, protocol, reconnectPolicy);\r\n    }\r\n\r\n    private constructor(connection: IConnection, logger: ILogger, protocol: IHubProtocol, reconnectPolicy?: IRetryPolicy) {\r\n        Arg.isRequired(connection, \"connection\");\r\n        Arg.isRequired(logger, \"logger\");\r\n        Arg.isRequired(protocol, \"protocol\");\r\n\r\n        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;\r\n        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;\r\n\r\n        this.logger = logger;\r\n        this.protocol = protocol;\r\n        this.connection = connection;\r\n        this.reconnectPolicy = reconnectPolicy;\r\n        this.handshakeProtocol = new HandshakeProtocol();\r\n\r\n        this.connection.onreceive = (data: any) => this.processIncomingData(data);\r\n        this.connection.onclose = (error?: Error) => this.connectionClosed(error);\r\n\r\n        this.callbacks = {};\r\n        this.methods = {};\r\n        this.closedCallbacks = [];\r\n        this.reconnectingCallbacks = [];\r\n        this.reconnectedCallbacks = [];\r\n        this.invocationId = 0;\r\n        this.receivedHandshakeResponse = false;\r\n        this.connectionState = HubConnectionState.Disconnected;\r\n        this.connectionStarted = false;\r\n\r\n        this.cachedPingMessage = this.protocol.writeMessage({ type: MessageType.Ping });\r\n    }\r\n\r\n    /** Indicates the state of the {@link HubConnection} to the server. */\r\n    get state(): HubConnectionState {\r\n        return this.connectionState;\r\n    }\r\n\r\n    /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either\r\n     *  in the disconnected state or if the negotiation step was skipped.\r\n     */\r\n    get connectionId(): string | null {\r\n        return this.connection ? (this.connection.connectionId || null) : null;\r\n    }\r\n\r\n    /** Indicates the url of the {@link HubConnection} to the server. */\r\n    get baseUrl(): string {\r\n        return this.connection.baseUrl || \"\";\r\n    }\r\n\r\n    /**\r\n     * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or\r\n     * Reconnecting states.\r\n     * @param {string} url The url to connect to.\r\n     */\r\n    set baseUrl(url: string) {\r\n        if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {\r\n            throw new Error(\"The HubConnection must be in the Disconnected or Reconnecting state to change the url.\");\r\n        }\r\n\r\n        if (!url) {\r\n            throw new Error(\"The HubConnection url must be a valid url.\");\r\n        }\r\n\r\n        this.connection.baseUrl = url;\r\n    }\r\n\r\n    /** Starts the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.\r\n     */\r\n    public start(): Promise<void> {\r\n        this.startPromise = this.startWithStateTransitions();\r\n        return this.startPromise;\r\n    }\r\n\r\n    private async startWithStateTransitions(): Promise<void> {\r\n        if (this.connectionState !== HubConnectionState.Disconnected) {\r\n            return Promise.reject(new Error(\"Cannot start a HubConnection that is not in the 'Disconnected' state.\"));\r\n        }\r\n\r\n        this.connectionState = HubConnectionState.Connecting;\r\n        this.logger.log(LogLevel.Debug, \"Starting HubConnection.\");\r\n\r\n        try {\r\n            await this.startInternal();\r\n\r\n            this.connectionState = HubConnectionState.Connected;\r\n            this.connectionStarted = true;\r\n            this.logger.log(LogLevel.Debug, \"HubConnection connected successfully.\");\r\n        } catch (e) {\r\n            this.connectionState = HubConnectionState.Disconnected;\r\n            this.logger.log(LogLevel.Debug, `HubConnection failed to start successfully because of error '${e}'.`);\r\n            return Promise.reject(e);\r\n        }\r\n    }\r\n\r\n    private async startInternal() {\r\n        this.stopDuringStartError = undefined;\r\n        this.receivedHandshakeResponse = false;\r\n        // Set up the promise before any connection is (re)started otherwise it could race with received messages\r\n        const handshakePromise = new Promise((resolve, reject) => {\r\n            this.handshakeResolver = resolve;\r\n            this.handshakeRejecter = reject;\r\n        });\r\n\r\n        await this.connection.start(this.protocol.transferFormat);\r\n\r\n        try {\r\n            const handshakeRequest: HandshakeRequestMessage = {\r\n                protocol: this.protocol.name,\r\n                version: this.protocol.version,\r\n            };\r\n\r\n            this.logger.log(LogLevel.Debug, \"Sending handshake request.\");\r\n\r\n            await this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest));\r\n\r\n            this.logger.log(LogLevel.Information, `Using HubProtocol '${this.protocol.name}'.`);\r\n\r\n            // defensively cleanup timeout in case we receive a message from the server before we finish start\r\n            this.cleanupTimeout();\r\n            this.resetTimeoutPeriod();\r\n            this.resetKeepAliveInterval();\r\n\r\n            await handshakePromise;\r\n\r\n            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise\r\n            // being rejected on close, because this continuation can run after both the handshake completed successfully\r\n            // and the connection was closed.\r\n            if (this.stopDuringStartError) {\r\n                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state\r\n                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise\r\n                // will cause the calling continuation to get scheduled to run later.\r\n                throw this.stopDuringStartError;\r\n            }\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`);\r\n\r\n            this.cleanupTimeout();\r\n            this.cleanupPingTimer();\r\n\r\n            // HttpConnection.stop() should not complete until after the onclose callback is invoked.\r\n            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.\r\n            await this.connection.stop(e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /** Stops the connection.\r\n     *\r\n     * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.\r\n     */\r\n    public async stop(): Promise<void> {\r\n        // Capture the start promise before the connection might be restarted in an onclose callback.\r\n        const startPromise = this.startPromise;\r\n\r\n        this.stopPromise = this.stopInternal();\r\n        await this.stopPromise;\r\n\r\n        try {\r\n            // Awaiting undefined continues immediately\r\n            await startPromise;\r\n        } catch (e) {\r\n            // This exception is returned to the user as a rejected Promise from the start method.\r\n        }\r\n    }\r\n\r\n    private stopInternal(error?: Error): Promise<void> {\r\n        if (this.connectionState === HubConnectionState.Disconnected) {\r\n            this.logger.log(LogLevel.Debug, `Call to HubConnection.stop(${error}) ignored because it is already in the disconnected state.`);\r\n            return Promise.resolve();\r\n        }\r\n\r\n        if (this.connectionState === HubConnectionState.Disconnecting) {\r\n            this.logger.log(LogLevel.Debug, `Call to HttpConnection.stop(${error}) ignored because the connection is already in the disconnecting state.`);\r\n            return this.stopPromise!;\r\n        }\r\n\r\n        this.connectionState = HubConnectionState.Disconnecting;\r\n\r\n        this.logger.log(LogLevel.Debug, \"Stopping HubConnection.\");\r\n\r\n        if (this.reconnectDelayHandle) {\r\n            // We're in a reconnect delay which means the underlying connection is currently already stopped.\r\n            // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and\r\n            // fire the onclose callbacks.\r\n            this.logger.log(LogLevel.Debug, \"Connection stopped during reconnect delay. Done reconnecting.\");\r\n\r\n            clearTimeout(this.reconnectDelayHandle);\r\n            this.reconnectDelayHandle = undefined;\r\n\r\n            this.completeClose();\r\n            return Promise.resolve();\r\n        }\r\n\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n        this.stopDuringStartError = error || new Error(\"The connection was stopped before the hub handshake could complete.\");\r\n\r\n        // HttpConnection.stop() should not complete until after either HttpConnection.start() fails\r\n        // or the onclose callback is invoked. The onclose callback will transition the HubConnection\r\n        // to the disconnected state if need be before HttpConnection.stop() completes.\r\n        return this.connection.stop(error);\r\n    }\r\n\r\n    /** Invokes a streaming hub method on the server using the specified name and arguments.\r\n     *\r\n     * @typeparam T The type of the items returned by the server.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {IStreamResult<T>} An object that yields results from the server as they are received.\r\n     */\r\n    public stream<T = any>(methodName: string, ...args: any[]): IStreamResult<T> {\r\n        const [streams, streamIds] = this.replaceStreamingParams(args);\r\n        const invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);\r\n\r\n        let promiseQueue: Promise<void>;\r\n        const subject = new Subject<T>();\r\n        subject.cancelCallback = () => {\r\n            const cancelInvocation: CancelInvocationMessage = this.createCancelInvocation(invocationDescriptor.invocationId);\r\n\r\n            delete this.callbacks[invocationDescriptor.invocationId];\r\n\r\n            return promiseQueue.then(() => {\r\n                return this.sendWithProtocol(cancelInvocation);\r\n            });\r\n        };\r\n\r\n        this.callbacks[invocationDescriptor.invocationId] = (invocationEvent: CompletionMessage | StreamItemMessage | null, error?: Error) => {\r\n            if (error) {\r\n                subject.error(error);\r\n                return;\r\n            } else if (invocationEvent) {\r\n                // invocationEvent will not be null when an error is not passed to the callback\r\n                if (invocationEvent.type === MessageType.Completion) {\r\n                    if (invocationEvent.error) {\r\n                        subject.error(new Error(invocationEvent.error));\r\n                    } else {\r\n                        subject.complete();\r\n                    }\r\n                } else {\r\n                    subject.next((invocationEvent.item) as T);\r\n                }\r\n            }\r\n        };\r\n\r\n        promiseQueue = this.sendWithProtocol(invocationDescriptor)\r\n            .catch((e) => {\r\n                subject.error(e);\r\n                delete this.callbacks[invocationDescriptor.invocationId];\r\n            });\r\n\r\n        this.launchStreams(streams, promiseQueue);\r\n\r\n        return subject;\r\n    }\r\n\r\n    private sendMessage(message: any) {\r\n        this.resetKeepAliveInterval();\r\n        return this.connection.send(message);\r\n    }\r\n\r\n    /**\r\n     * Sends a js object to the server.\r\n     * @param message The js object to serialize and send.\r\n     */\r\n    private sendWithProtocol(message: any) {\r\n        return this.sendMessage(this.protocol.writeMessage(message));\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.\r\n     *\r\n     * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still\r\n     * be processing the invocation.\r\n     *\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.\r\n     */\r\n    public send(methodName: string, ...args: any[]): Promise<void> {\r\n        const [streams, streamIds] = this.replaceStreamingParams(args);\r\n        const sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));\r\n\r\n        this.launchStreams(streams, sendPromise);\r\n\r\n        return sendPromise;\r\n    }\r\n\r\n    /** Invokes a hub method on the server using the specified name and arguments.\r\n     *\r\n     * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise\r\n     * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of\r\n     * resolving the Promise.\r\n     *\r\n     * @typeparam T The expected return type.\r\n     * @param {string} methodName The name of the server method to invoke.\r\n     * @param {any[]} args The arguments used to invoke the server method.\r\n     * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.\r\n     */\r\n    public invoke<T = any>(methodName: string, ...args: any[]): Promise<T> {\r\n        const [streams, streamIds] = this.replaceStreamingParams(args);\r\n        const invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);\r\n\r\n        const p = new Promise<any>((resolve, reject) => {\r\n            // invocationId will always have a value for a non-blocking invocation\r\n            this.callbacks[invocationDescriptor.invocationId!] = (invocationEvent: StreamItemMessage | CompletionMessage | null, error?: Error) => {\r\n                if (error) {\r\n                    reject(error);\r\n                    return;\r\n                } else if (invocationEvent) {\r\n                    // invocationEvent will not be null when an error is not passed to the callback\r\n                    if (invocationEvent.type === MessageType.Completion) {\r\n                        if (invocationEvent.error) {\r\n                            reject(new Error(invocationEvent.error));\r\n                        } else {\r\n                            resolve(invocationEvent.result);\r\n                        }\r\n                    } else {\r\n                        reject(new Error(`Unexpected message type: ${invocationEvent.type}`));\r\n                    }\r\n                }\r\n            };\r\n\r\n            const promiseQueue = this.sendWithProtocol(invocationDescriptor)\r\n                .catch((e) => {\r\n                    reject(e);\r\n                    // invocationId will always have a value for a non-blocking invocation\r\n                    delete this.callbacks[invocationDescriptor.invocationId!];\r\n                });\r\n\r\n            this.launchStreams(streams, promiseQueue);\r\n        });\r\n\r\n        return p;\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.\r\n     *\r\n     * @param {string} methodName The name of the hub method to define.\r\n     * @param {Function} newMethod The handler that will be raised when the hub method is invoked.\r\n     */\r\n    public on(methodName: string, newMethod: (...args: any[]) => void) {\r\n        if (!methodName || !newMethod) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        if (!this.methods[methodName]) {\r\n            this.methods[methodName] = [];\r\n        }\r\n\r\n        // Preventing adding the same handler multiple times.\r\n        if (this.methods[methodName].indexOf(newMethod) !== -1) {\r\n            return;\r\n        }\r\n\r\n        this.methods[methodName].push(newMethod);\r\n    }\r\n\r\n    /** Removes all handlers for the specified hub method.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     */\r\n    public off(methodName: string): void;\r\n\r\n    /** Removes the specified handler for the specified hub method.\r\n     *\r\n     * You must pass the exact same Function instance as was previously passed to {@link @microsoft/signalr.HubConnection.on}. Passing a different instance (even if the function\r\n     * body is the same) will not remove the handler.\r\n     *\r\n     * @param {string} methodName The name of the method to remove handlers for.\r\n     * @param {Function} method The handler to remove. This must be the same Function instance as the one passed to {@link @microsoft/signalr.HubConnection.on}.\r\n     */\r\n    public off(methodName: string, method: (...args: any[]) => void): void;\r\n    public off(methodName: string, method?: (...args: any[]) => void): void {\r\n        if (!methodName) {\r\n            return;\r\n        }\r\n\r\n        methodName = methodName.toLowerCase();\r\n        const handlers = this.methods[methodName];\r\n        if (!handlers) {\r\n            return;\r\n        }\r\n        if (method) {\r\n            const removeIdx = handlers.indexOf(method);\r\n            if (removeIdx !== -1) {\r\n                handlers.splice(removeIdx, 1);\r\n                if (handlers.length === 0) {\r\n                    delete this.methods[methodName];\r\n                }\r\n            }\r\n        } else {\r\n            delete this.methods[methodName];\r\n        }\r\n\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection is closed.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).\r\n     */\r\n    public onclose(callback: (error?: Error) => void) {\r\n        if (callback) {\r\n            this.closedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection starts reconnecting.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).\r\n     */\r\n    public onreconnecting(callback: (error?: Error) => void) {\r\n        if (callback) {\r\n            this.reconnectingCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    /** Registers a handler that will be invoked when the connection successfully reconnects.\r\n     *\r\n     * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.\r\n     */\r\n    public onreconnected(callback: (connectionId?: string) => void) {\r\n        if (callback) {\r\n            this.reconnectedCallbacks.push(callback);\r\n        }\r\n    }\r\n\r\n    private processIncomingData(data: any) {\r\n        this.cleanupTimeout();\r\n\r\n        if (!this.receivedHandshakeResponse) {\r\n            data = this.processHandshakeResponse(data);\r\n            this.receivedHandshakeResponse = true;\r\n        }\r\n\r\n        // Data may have all been read when processing handshake response\r\n        if (data) {\r\n            // Parse the messages\r\n            const messages = this.protocol.parseMessages(data, this.logger);\r\n\r\n            for (const message of messages) {\r\n                switch (message.type) {\r\n                    case MessageType.Invocation:\r\n                        this.invokeClientMethod(message);\r\n                        break;\r\n                    case MessageType.StreamItem:\r\n                    case MessageType.Completion:\r\n                        const callback = this.callbacks[message.invocationId];\r\n                        if (callback) {\r\n                            if (message.type === MessageType.Completion) {\r\n                                delete this.callbacks[message.invocationId];\r\n                            }\r\n                            callback(message);\r\n                        }\r\n                        break;\r\n                    case MessageType.Ping:\r\n                        // Don't care about pings\r\n                        break;\r\n                    case MessageType.Close:\r\n                        this.logger.log(LogLevel.Information, \"Close message received from server.\");\r\n\r\n                        const error = message.error ? new Error(\"Server returned an error on close: \" + message.error) : undefined;\r\n\r\n                        if (message.allowReconnect === true) {\r\n                            // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,\r\n                            // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.\r\n\r\n                            // tslint:disable-next-line:no-floating-promises\r\n                            this.connection.stop(error);\r\n                        } else {\r\n                            // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.\r\n                            this.stopPromise = this.stopInternal(error);\r\n                        }\r\n\r\n                        break;\r\n                    default:\r\n                        this.logger.log(LogLevel.Warning, `Invalid message type: ${message.type}.`);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.resetTimeoutPeriod();\r\n    }\r\n\r\n    private processHandshakeResponse(data: any): any {\r\n        let responseMessage: HandshakeResponseMessage;\r\n        let remainingData: any;\r\n\r\n        try {\r\n            [remainingData, responseMessage] = this.handshakeProtocol.parseHandshakeResponse(data);\r\n        } catch (e) {\r\n            const message = \"Error parsing handshake response: \" + e;\r\n            this.logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        }\r\n        if (responseMessage.error) {\r\n            const message = \"Server returned handshake error: \" + responseMessage.error;\r\n            this.logger.log(LogLevel.Error, message);\r\n\r\n            const error = new Error(message);\r\n            this.handshakeRejecter(error);\r\n            throw error;\r\n        } else {\r\n            this.logger.log(LogLevel.Debug, \"Server handshake complete.\");\r\n        }\r\n\r\n        this.handshakeResolver();\r\n        return remainingData;\r\n    }\r\n\r\n    private resetKeepAliveInterval() {\r\n        if (this.connection.features.inherentKeepAlive) {\r\n            return;\r\n        }\r\n\r\n        // Set the time we want the next keep alive to be sent\r\n        // Timer will be setup on next message receive\r\n        this.nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;\r\n\r\n        this.cleanupPingTimer();\r\n    }\r\n\r\n    private resetTimeoutPeriod() {\r\n        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {\r\n            // Set the timeout timer\r\n            this.timeoutHandle = setTimeout(() => this.serverTimeout(), this.serverTimeoutInMilliseconds);\r\n\r\n            // Set keepAlive timer if there isn't one\r\n            if (this.pingServerHandle === undefined) {\r\n                let nextPing = this.nextKeepAlive - new Date().getTime();\r\n                if (nextPing < 0) {\r\n                    nextPing = 0;\r\n                }\r\n\r\n                // The timer needs to be set from a networking callback to avoid Chrome timer throttling from causing timers to run once a minute\r\n                this.pingServerHandle = setTimeout(async () => {\r\n                    if (this.connectionState === HubConnectionState.Connected) {\r\n                        try {\r\n                            await this.sendMessage(this.cachedPingMessage);\r\n                        } catch {\r\n                            // We don't care about the error. It should be seen elsewhere in the client.\r\n                            // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering\r\n                            this.cleanupPingTimer();\r\n                        }\r\n                    }\r\n                }, nextPing);\r\n            }\r\n        }\r\n    }\r\n\r\n    private serverTimeout() {\r\n        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(\r\n        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.\r\n        // tslint:disable-next-line:no-floating-promises\r\n        this.connection.stop(new Error(\"Server timeout elapsed without receiving a message from the server.\"));\r\n    }\r\n\r\n    private invokeClientMethod(invocationMessage: InvocationMessage) {\r\n        const methods = this.methods[invocationMessage.target.toLowerCase()];\r\n        if (methods) {\r\n            try {\r\n                methods.forEach((m) => m.apply(this, invocationMessage.arguments));\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `A callback for the method ${invocationMessage.target.toLowerCase()} threw error '${e}'.`);\r\n            }\r\n\r\n            if (invocationMessage.invocationId) {\r\n                // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.\r\n                const message = \"Server requested a response, which is not supported in this version of the client.\";\r\n                this.logger.log(LogLevel.Error, message);\r\n\r\n                // We don't want to wait on the stop itself.\r\n                this.stopPromise = this.stopInternal(new Error(message));\r\n            }\r\n        } else {\r\n            this.logger.log(LogLevel.Warning, `No client method with the name '${invocationMessage.target}' found.`);\r\n        }\r\n    }\r\n\r\n    private connectionClosed(error?: Error) {\r\n        this.logger.log(LogLevel.Debug, `HubConnection.connectionClosed(${error}) called while in state ${this.connectionState}.`);\r\n\r\n        // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.\r\n        this.stopDuringStartError = this.stopDuringStartError || error || new Error(\"The underlying connection was closed before the hub handshake could complete.\");\r\n\r\n        // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.\r\n        // If it has already completed, this should just noop.\r\n        if (this.handshakeResolver) {\r\n            this.handshakeResolver();\r\n        }\r\n\r\n        this.cancelCallbacksWithError(error || new Error(\"Invocation canceled due to the underlying connection being closed.\"));\r\n\r\n        this.cleanupTimeout();\r\n        this.cleanupPingTimer();\r\n\r\n        if (this.connectionState === HubConnectionState.Disconnecting) {\r\n            this.completeClose(error);\r\n        } else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {\r\n            // tslint:disable-next-line:no-floating-promises\r\n            this.reconnect(error);\r\n        } else if (this.connectionState === HubConnectionState.Connected) {\r\n            this.completeClose(error);\r\n        }\r\n\r\n        // If none of the above if conditions were true were called the HubConnection must be in either:\r\n        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.\r\n        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt\r\n        //    and potentially continue the reconnect() loop.\r\n        // 3. The Disconnected state in which case we're already done.\r\n    }\r\n\r\n    private completeClose(error?: Error) {\r\n        if (this.connectionStarted) {\r\n            this.connectionState = HubConnectionState.Disconnected;\r\n            this.connectionStarted = false;\r\n\r\n            try {\r\n                this.closedCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `An onclose callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    private async reconnect(error?: Error) {\r\n        const reconnectStartTime = Date.now();\r\n        let previousReconnectAttempts = 0;\r\n        let retryError = error !== undefined ? error : new Error(\"Attempting to reconnect due to a unknown error.\");\r\n\r\n        let nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);\r\n\r\n        if (nextRetryDelay === null) {\r\n            this.logger.log(LogLevel.Debug, \"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.\");\r\n            this.completeClose(error);\r\n            return;\r\n        }\r\n\r\n        this.connectionState = HubConnectionState.Reconnecting;\r\n\r\n        if (error) {\r\n            this.logger.log(LogLevel.Information, `Connection reconnecting because of error '${error}'.`);\r\n        } else {\r\n            this.logger.log(LogLevel.Information, \"Connection reconnecting.\");\r\n        }\r\n\r\n        if (this.onreconnecting) {\r\n            try {\r\n                this.reconnectingCallbacks.forEach((c) => c.apply(this, [error]));\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Error, `An onreconnecting callback called with error '${error}' threw error '${e}'.`);\r\n            }\r\n\r\n            // Exit early if an onreconnecting callback called connection.stop().\r\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        while (nextRetryDelay !== null) {\r\n            this.logger.log(LogLevel.Information, `Reconnect attempt number ${previousReconnectAttempts} will start in ${nextRetryDelay} ms.`);\r\n\r\n            await new Promise((resolve) => {\r\n                this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay!);\r\n            });\r\n            this.reconnectDelayHandle = undefined;\r\n\r\n            if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                this.logger.log(LogLevel.Debug, \"Connection left the reconnecting state during reconnect delay. Done reconnecting.\");\r\n                return;\r\n            }\r\n\r\n            try {\r\n                await this.startInternal();\r\n\r\n                this.connectionState = HubConnectionState.Connected;\r\n                this.logger.log(LogLevel.Information, \"HubConnection reconnected successfully.\");\r\n\r\n                if (this.onreconnected) {\r\n                    try {\r\n                        this.reconnectedCallbacks.forEach((c) => c.apply(this, [this.connection.connectionId]));\r\n                    } catch (e) {\r\n                        this.logger.log(LogLevel.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`);\r\n                    }\r\n                }\r\n\r\n                return;\r\n            } catch (e) {\r\n                this.logger.log(LogLevel.Information, `Reconnect attempt failed because of error '${e}'.`);\r\n\r\n                if (this.connectionState !== HubConnectionState.Reconnecting) {\r\n                    this.logger.log(LogLevel.Debug, `Connection moved to the '${this.connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`);\r\n                    // The TypeScript compiler thinks that connectionState must be Connected here. The TypeScript compiler is wrong.\r\n                    if (this.connectionState as any === HubConnectionState.Disconnecting) {\r\n                        this.completeClose();\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                retryError = e instanceof Error ? e : new Error(e.toString());\r\n                nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);\r\n            }\r\n        }\r\n\r\n        this.logger.log(LogLevel.Information, `Reconnect retries have been exhausted after ${Date.now() - reconnectStartTime} ms and ${previousReconnectAttempts} failed attempts. Connection disconnecting.`);\r\n\r\n        this.completeClose();\r\n    }\r\n\r\n    private getNextRetryDelay(previousRetryCount: number, elapsedMilliseconds: number, retryReason: Error) {\r\n        try {\r\n            return this.reconnectPolicy!.nextRetryDelayInMilliseconds({\r\n                elapsedMilliseconds,\r\n                previousRetryCount,\r\n                retryReason,\r\n            });\r\n        } catch (e) {\r\n            this.logger.log(LogLevel.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${previousRetryCount}, ${elapsedMilliseconds}) threw error '${e}'.`);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private cancelCallbacksWithError(error: Error) {\r\n        const callbacks = this.callbacks;\r\n        this.callbacks = {};\r\n\r\n        Object.keys(callbacks)\r\n            .forEach((key) => {\r\n                const callback = callbacks[key];\r\n                callback(null, error);\r\n            });\r\n    }\r\n\r\n    private cleanupPingTimer(): void {\r\n        if (this.pingServerHandle) {\r\n            clearTimeout(this.pingServerHandle);\r\n            this.pingServerHandle = undefined;\r\n        }\r\n    }\r\n\r\n    private cleanupTimeout(): void {\r\n        if (this.timeoutHandle) {\r\n            clearTimeout(this.timeoutHandle);\r\n        }\r\n    }\r\n\r\n    private createInvocation(methodName: string, args: any[], nonblocking: boolean, streamIds: string[]): InvocationMessage {\r\n        if (nonblocking) {\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    arguments: args,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        } else {\r\n            const invocationId = this.invocationId;\r\n            this.invocationId++;\r\n\r\n            if (streamIds.length !== 0) {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    streamIds,\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            } else {\r\n                return {\r\n                    arguments: args,\r\n                    invocationId: invocationId.toString(),\r\n                    target: methodName,\r\n                    type: MessageType.Invocation,\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    private launchStreams(streams: Array<IStreamResult<any>>, promiseQueue: Promise<void>): void {\r\n        if (streams.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Synchronize stream data so they arrive in-order on the server\r\n        if (!promiseQueue) {\r\n            promiseQueue = Promise.resolve();\r\n        }\r\n\r\n        // We want to iterate over the keys, since the keys are the stream ids\r\n        // tslint:disable-next-line:forin\r\n        for (const streamId in streams) {\r\n            streams[streamId].subscribe({\r\n                complete: () => {\r\n                    promiseQueue = promiseQueue.then(() => this.sendWithProtocol(this.createCompletionMessage(streamId)));\r\n                },\r\n                error: (err) => {\r\n                    let message: string;\r\n                    if (err instanceof Error) {\r\n                        message = err.message;\r\n                    } else if (err && err.toString) {\r\n                        message = err.toString();\r\n                    } else {\r\n                        message = \"Unknown error\";\r\n                    }\r\n\r\n                    promiseQueue = promiseQueue.then(() => this.sendWithProtocol(this.createCompletionMessage(streamId, message)));\r\n                },\r\n                next: (item) => {\r\n                    promiseQueue = promiseQueue.then(() => this.sendWithProtocol(this.createStreamItemMessage(streamId, item)));\r\n                },\r\n            });\r\n        }\r\n    }\r\n\r\n    private replaceStreamingParams(args: any[]): [Array<IStreamResult<any>>, string[]] {\r\n        const streams: Array<IStreamResult<any>> = [];\r\n        const streamIds: string[] = [];\r\n        for (let i = 0; i < args.length; i++) {\r\n            const argument = args[i];\r\n            if (this.isObservable(argument)) {\r\n                const streamId = this.invocationId;\r\n                this.invocationId++;\r\n                // Store the stream for later use\r\n                streams[streamId] = argument;\r\n                streamIds.push(streamId.toString());\r\n\r\n                // remove stream from args\r\n                args.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        return [streams, streamIds];\r\n    }\r\n\r\n    private isObservable(arg: any): arg is IStreamResult<any> {\r\n        // This allows other stream implementations to just work (like rxjs)\r\n        return arg && arg.subscribe && typeof arg.subscribe === \"function\";\r\n    }\r\n\r\n    private createStreamInvocation(methodName: string, args: any[], streamIds: string[]): StreamInvocationMessage {\r\n        const invocationId = this.invocationId;\r\n        this.invocationId++;\r\n\r\n        if (streamIds.length !== 0) {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                streamIds,\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        } else {\r\n            return {\r\n                arguments: args,\r\n                invocationId: invocationId.toString(),\r\n                target: methodName,\r\n                type: MessageType.StreamInvocation,\r\n            };\r\n        }\r\n    }\r\n\r\n    private createCancelInvocation(id: string): CancelInvocationMessage {\r\n        return {\r\n            invocationId: id,\r\n            type: MessageType.CancelInvocation,\r\n        };\r\n    }\r\n\r\n    private createStreamItemMessage(id: string, item: any): StreamItemMessage {\r\n        return {\r\n            invocationId: id,\r\n            item,\r\n            type: MessageType.StreamItem,\r\n        };\r\n    }\r\n\r\n    private createCompletionMessage(id: string, error?: any, result?: any): CompletionMessage {\r\n        if (error) {\r\n            return {\r\n                error,\r\n                invocationId: id,\r\n                type: MessageType.Completion,\r\n            };\r\n        }\r\n\r\n        return {\r\n            invocationId: id,\r\n            result,\r\n            type: MessageType.Completion,\r\n        };\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}