{"ast":null,"code":"// Copyright (c) .NET Foundation. All rights reserved.\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || Object.assign || function (t) {\n  for (var s, i = 1, n = arguments.length; i < n; i++) {\n    s = arguments[i];\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n  }\n  return t;\n};\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\nimport { HttpClient, HttpResponse } from \"./HttpClient\";\nimport { LogLevel } from \"./ILogger\";\nimport { Platform } from \"./Utils\";\nvar FetchHttpClient = /** @class */function (_super) {\n  __extends(FetchHttpClient, _super);\n  function FetchHttpClient(logger) {\n    var _this = _super.call(this) || this;\n    _this.logger = logger;\n    if (typeof fetch === \"undefined\") {\n      // In order to ignore the dynamic require in webpack builds we need to do this magic\n      // @ts-ignore: TS doesn't know about these names\n      var requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\n      // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\n      _this.jar = new (requireFunc(\"tough-cookie\").CookieJar)();\n      _this.fetchType = requireFunc(\"node-fetch\");\n      // node-fetch doesn't have a nice API for getting and setting cookies\n      // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\n      _this.fetchType = requireFunc(\"fetch-cookie\")(_this.fetchType, _this.jar);\n      // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\n      _this.abortControllerType = requireFunc(\"abort-controller\");\n    } else {\n      _this.fetchType = fetch.bind(self);\n      _this.abortControllerType = AbortController;\n    }\n    return _this;\n  }\n  /** @inheritDoc */\n  FetchHttpClient.prototype.send = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var abortController, error, timeoutId, msTimeout, response, e_1, content, payload;\n      var _this = this;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Check that abort was not signaled before calling send\n            if (request.abortSignal && request.abortSignal.aborted) {\n              throw new AbortError();\n            }\n            if (!request.method) {\n              throw new Error(\"No method defined.\");\n            }\n            if (!request.url) {\n              throw new Error(\"No url defined.\");\n            }\n            abortController = new this.abortControllerType();\n            // Hook our abortSignal into the abort controller\n            if (request.abortSignal) {\n              request.abortSignal.onabort = function () {\n                abortController.abort();\n                error = new AbortError();\n              };\n            }\n            timeoutId = null;\n            if (request.timeout) {\n              msTimeout = request.timeout;\n              timeoutId = setTimeout(function () {\n                abortController.abort();\n                _this.logger.log(LogLevel.Warning, \"Timeout from HTTP request.\");\n                error = new TimeoutError();\n              }, msTimeout);\n            }\n            _a.label = 1;\n          case 1:\n            _a.trys.push([1, 3, 4, 5]);\n            return [4 /*yield*/, this.fetchType(request.url, {\n              body: request.content,\n              cache: \"no-cache\",\n              credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\n              headers: __assign({\n                \"Content-Type\": \"text/plain;charset=UTF-8\",\n                \"X-Requested-With\": \"XMLHttpRequest\"\n              }, request.headers),\n              method: request.method,\n              mode: \"cors\",\n              redirect: \"manual\",\n              signal: abortController.signal\n            })];\n          case 2:\n            response = _a.sent();\n            return [3 /*break*/, 5];\n          case 3:\n            e_1 = _a.sent();\n            if (error) {\n              throw error;\n            }\n            this.logger.log(LogLevel.Warning, \"Error from HTTP request. \" + e_1 + \".\");\n            throw e_1;\n          case 4:\n            if (timeoutId) {\n              clearTimeout(timeoutId);\n            }\n            if (request.abortSignal) {\n              request.abortSignal.onabort = null;\n            }\n            return [7 /*endfinally*/];\n          case 5:\n            if (!response.ok) {\n              throw new HttpError(response.statusText, response.status);\n            }\n            content = deserializeContent(response, request.responseType);\n            return [4 /*yield*/, content];\n          case 6:\n            payload = _a.sent();\n            return [2 /*return*/, new HttpResponse(response.status, response.statusText, payload)];\n        }\n      });\n    });\n  };\n  FetchHttpClient.prototype.getCookieString = function (url) {\n    var cookies = \"\";\n    if (Platform.isNode && this.jar) {\n      // @ts-ignore: unused variable\n      this.jar.getCookies(url, function (e, c) {\n        return cookies = c.join(\"; \");\n      });\n    }\n    return cookies;\n  };\n  return FetchHttpClient;\n}(HttpClient);\nexport { FetchHttpClient };\nfunction deserializeContent(response, responseType) {\n  var content;\n  switch (responseType) {\n    case \"arraybuffer\":\n      content = response.arrayBuffer();\n      break;\n    case \"text\":\n      content = response.text();\n      break;\n    case \"blob\":\n    case \"document\":\n    case \"json\":\n      throw new Error(responseType + \" is not supported.\");\n    default:\n      content = response.text();\n      break;\n  }\n  return content;\n}","map":{"version":3,"names":["AbortError","HttpError","TimeoutError","HttpClient","HttpResponse","LogLevel","Platform","FetchHttpClient","_super","__extends","logger","_this","call","fetch","requireFunc","__webpack_require__","__non_webpack_require__","require","jar","CookieJar","fetchType","abortControllerType","bind","self","AbortController","prototype","send","request","abortSignal","aborted","method","Error","url","abortController","onabort","abort","error","timeoutId","timeout","msTimeout","setTimeout","log","Warning","body","content","cache","credentials","withCredentials","headers","__assign","mode","redirect","signal","response","_a","sent","e_1","clearTimeout","ok","statusText","status","deserializeContent","responseType","payload","getCookieString","cookies","isNode","getCookies","e","c","join","arrayBuffer","text"],"sources":["../../src/FetchHttpClient.ts"],"sourcesContent":["// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n// @ts-ignore: This will be removed from built files and is here to make the types available during dev work\r\nimport * as tough from \"@types/tough-cookie\";\r\n\r\nimport { AbortError, HttpError, TimeoutError } from \"./Errors\";\r\nimport { HttpClient, HttpRequest, HttpResponse } from \"./HttpClient\";\r\nimport { ILogger, LogLevel } from \"./ILogger\";\r\nimport { Platform } from \"./Utils\";\r\n\r\nexport class FetchHttpClient extends HttpClient {\r\n    private readonly abortControllerType: { prototype: AbortController, new(): AbortController };\r\n    private readonly fetchType: (input: RequestInfo, init?: RequestInit) => Promise<Response>;\r\n    private readonly jar?: tough.CookieJar;\r\n\r\n    private readonly logger: ILogger;\r\n\r\n    public constructor(logger: ILogger) {\r\n        super();\r\n        this.logger = logger;\r\n\r\n        if (typeof fetch === \"undefined\") {\r\n            // In order to ignore the dynamic require in webpack builds we need to do this magic\r\n            // @ts-ignore: TS doesn't know about these names\r\n            const requireFunc = typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require;\r\n\r\n            // Cookies aren't automatically handled in Node so we need to add a CookieJar to preserve cookies across requests\r\n            this.jar = new (requireFunc(\"tough-cookie\")).CookieJar();\r\n            this.fetchType = requireFunc(\"node-fetch\");\r\n\r\n            // node-fetch doesn't have a nice API for getting and setting cookies\r\n            // fetch-cookie will wrap a fetch implementation with a default CookieJar or a provided one\r\n            this.fetchType = requireFunc(\"fetch-cookie\")(this.fetchType, this.jar);\r\n\r\n            // Node needs EventListener methods on AbortController which our custom polyfill doesn't provide\r\n            this.abortControllerType = requireFunc(\"abort-controller\");\r\n        } else {\r\n            this.fetchType = fetch.bind(self);\r\n            this.abortControllerType = AbortController;\r\n        }\r\n    }\r\n\r\n    /** @inheritDoc */\r\n    public async send(request: HttpRequest): Promise<HttpResponse> {\r\n        // Check that abort was not signaled before calling send\r\n        if (request.abortSignal && request.abortSignal.aborted) {\r\n            throw new AbortError();\r\n        }\r\n\r\n        if (!request.method) {\r\n            throw new Error(\"No method defined.\");\r\n        }\r\n        if (!request.url) {\r\n            throw new Error(\"No url defined.\");\r\n        }\r\n\r\n        const abortController = new this.abortControllerType();\r\n\r\n        let error: any;\r\n        // Hook our abortSignal into the abort controller\r\n        if (request.abortSignal) {\r\n            request.abortSignal.onabort = () => {\r\n                abortController.abort();\r\n                error = new AbortError();\r\n            };\r\n        }\r\n\r\n        // If a timeout has been passed in, setup a timeout to call abort\r\n        // Type needs to be any to fit window.setTimeout and NodeJS.setTimeout\r\n        let timeoutId: any = null;\r\n        if (request.timeout) {\r\n            const msTimeout = request.timeout!;\r\n            timeoutId = setTimeout(() => {\r\n                abortController.abort();\r\n                this.logger.log(LogLevel.Warning, `Timeout from HTTP request.`);\r\n                error = new TimeoutError();\r\n            }, msTimeout);\r\n        }\r\n\r\n        let response: Response;\r\n        try {\r\n            response = await this.fetchType(request.url!, {\r\n                body: request.content!,\r\n                cache: \"no-cache\",\r\n                credentials: request.withCredentials === true ? \"include\" : \"same-origin\",\r\n                headers: {\r\n                    \"Content-Type\": \"text/plain;charset=UTF-8\",\r\n                    \"X-Requested-With\": \"XMLHttpRequest\",\r\n                    ...request.headers,\r\n                },\r\n                method: request.method!,\r\n                mode: \"cors\",\r\n                redirect: \"manual\",\r\n                signal: abortController.signal,\r\n            });\r\n        } catch (e) {\r\n            if (error) {\r\n                throw error;\r\n            }\r\n            this.logger.log(\r\n                LogLevel.Warning,\r\n                `Error from HTTP request. ${e}.`,\r\n            );\r\n            throw e;\r\n        } finally {\r\n            if (timeoutId) {\r\n                clearTimeout(timeoutId);\r\n            }\r\n            if (request.abortSignal) {\r\n                request.abortSignal.onabort = null;\r\n            }\r\n        }\r\n\r\n        if (!response.ok) {\r\n            throw new HttpError(response.statusText, response.status);\r\n        }\r\n\r\n        const content = deserializeContent(response, request.responseType);\r\n        const payload = await content;\r\n\r\n        return new HttpResponse(\r\n            response.status,\r\n            response.statusText,\r\n            payload,\r\n        );\r\n    }\r\n\r\n    public getCookieString(url: string): string {\r\n        let cookies: string = \"\";\r\n        if (Platform.isNode && this.jar) {\r\n            // @ts-ignore: unused variable\r\n            this.jar.getCookies(url, (e, c) => cookies = c.join(\"; \"));\r\n        }\r\n        return cookies;\r\n    }\r\n}\r\n\r\nfunction deserializeContent(response: Response, responseType?: XMLHttpRequestResponseType): Promise<string | ArrayBuffer> {\r\n    let content;\r\n    switch (responseType) {\r\n        case \"arraybuffer\":\r\n            content = response.arrayBuffer();\r\n            break;\r\n        case \"text\":\r\n            content = response.text();\r\n            break;\r\n        case \"blob\":\r\n        case \"document\":\r\n        case \"json\":\r\n            throw new Error(`${responseType} is not supported.`);\r\n        default:\r\n            content = response.text();\r\n            break;\r\n    }\r\n\r\n    return content;\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}